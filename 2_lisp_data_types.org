# -*- coding:utf-8-*-
#+TITLE: 2 Lisp Data Types
#+AUTHOR: liushangliang
#+EMAIL: phenix3443+github@gmail.com
#+STARTUP: overview
#+OPTIONS: num:nil

* 2 Lisp Data Types

  A Lisp object is a piece of data used and manipulated by Lisp programs. For our purposes, a type or data type is a set of possible objects.

  Lisp 对象是 Lisp 程序使用和操作的一段数据。在我们看来，类型或数据类型是一组可用的对象。

  Every object belongs to at least one type. Objects of the same type have similar structures and may usually be used in the same contexts. Types can overlap, and objects can belong to two or more types. Consequently, we can ask whether an object belongs to a particular type, but not for “the” type of an object.

  对象至少属于一种类型。相同类型的对象具有相似的结构，并且通常可以在相同的上下文中使用。类型可以重叠，对象可以属于两种或更多种类型。因此，我们可以查询对象是否属于特定类型，而不是对象的类型是哪一个。

  A few fundamental object types are built into Emacs. These, from which all other types are constructed, are called primitive types. Each object belongs to one and only one primitive type. These types include integer, float, cons, symbol, string, vector, hash-table, subr, and byte-code function, plus several special types, such as buffer, that are related to editing. (See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Editing-Types.html#Editing-Types][Editing Types]] .)

  Emacs 中内置了一些基本对象类型。所有其他类型都由这些基本类型构造，因此他们也被成为基本类型（primitive types）。每个对象属于一个且只有一个基本类型。这些类型包括 integer，float，cons，symbol，string，vector，hash-table，subr，byte-code function 和 record，以及与编辑相关的几种特殊类型，如缓冲区。 （请参 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Editing-Types.html#Editing-Types][Editing Types]] 。）

  Each primitive type has a corresponding Lisp function that checks whether an object is a member of that type.

  每个基本类型都有一个相应的 Lisp 函数，用于检查对象是否该类型。

  Lisp is unlike many other languages in that its objects are self-typing: the primitive type of each object is implicit in the object itself. For example, if an object is a vector, nothing can treat it as a number; Lisp knows it is a vector, not a number.

  Lisp 与许多其他语言不同，它的对象是自我键入的：每个对象的基本类型隐含在对象本身中。例如，如果一个对象是一个 vector，不可以把它当作一个数字; Lisp 知道它是一个 vector，而不是一个数字。

  In most languages, the programmer must declare the data type of each variable, and the type is known by the compiler but not represented in the data. Such type declarations do not exist in Emacs Lisp. A Lisp variable can have any type of value, and it remembers whatever value you store in it, type and all. (Actually, a small number of Emacs Lisp variables can only take on values of a certain type. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Variables-with-Restricted-Values.html#Variables-with-Restricted-Values][Variables with Restricted Values]] .)

  在大多数语言中，程序员必须声明每个变量的数据类型，类型被编译器感知，但不在数据中表示。Emacs Lisp 不存在类型声明。Lisp 变量可以具有任何类型的值，并且它会记住存储在其中的任何值，类型和所有事情。 （实际上，少量的 Emacs Lisp 变量只能采用某种类型的值。参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Variables-with-Restricted-Values.html#Variables-with-Restricted-Values][Variables with Restricted Values]] 。）

  This chapter describes the purpose, printed representation, and read syntax of each of the standard types in GNU Emacs Lisp. Details on how to use these types can be found in later chapters.

  本章介绍 GNU Emacs Lisp 中每种标准类型的用途，打印表示和读取语法。有关如何使用这些类型的详细信息，请参阅后面的章节。

  + Printed Representation: How Lisp objects are represented as text.

    打印表示：Lisp 对象如何表示为文本。

  + Comments: Comments and their formatting conventions.

    注释：注释及其格式约定。

  + Programming Types: Types found in all Lisp systems.

    编程类型：在所有 Lisp 系统中找到的类型。

  + Editing Types: Types specific to Emacs.

    编辑类型：特定于 Emacs 的类型。

  + Circular Objects: Read syntax for circular structure.

  + Type Predicates: Tests related to types.

    类型谓词：与类型相关的测试。

  + Equality Predicates: Tests of equality between any two objects.

    相等 Predicates：测试任何两个对象之间的相等性。

** 2.1 Printed Representation and Read Syntax（打印形式和读取语法）

   The printed representation of an object is the format of the output generated by the Lisp printer (the function prin1) for that object. Every data type has a unique printed representation. The read syntax of an object is the format of the input accepted by the Lisp reader (the function read) for that object. This is not necessarily unique; many kinds of object have more than one syntax. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Read-and-Print.html#Read-and-Print][Read and Print]] .

   对象的打印表示形式是 Lisp printer（prin1 函数）为该对象生成的输出格式。每种数据类型都有唯一的打印表示。对象的读取语法是该对象的 Lisp reader（read 函数）接受的输入格式。这不一定是唯一的; 很多种对象都有多种语法。请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Read-and-Print.html#Read-and-Print][Read and Print]] 。

   In most cases, an object's printed representation is also a read syntax for the object. However, some types have no read syntax, since it does not make sense to enter objects of these types as constants in a Lisp program. These objects are printed in hash notation, which consists of the characters ‘#<’, a descriptive string (typically the type name followed by the name of the object), and a closing ‘>’. For example:

   在大多数情况下，对象的打印表示也是对象的读取语法。但是，某些类型没有读取语法，因为在 Lisp 程序中将这些类型的对象作为常量输入是没有意义的。这些对象以散列表示法打印，即由字符'＃<'，描述性字符串（通常是类型名称后跟对象名称）和结束'>'组成。例如：
   #+BEGIN_EXAMPLE
(current-buffer)
⇒ #<buffer objects.texi>
   #+END_EXAMPLE

   Hash notation cannot be read at all, so the Lisp reader signals the error invalid-read-syntax whenever it encounters ‘#<’. In other languages, an expression is text; it has no other form. In Lisp, an expression is primarily a Lisp object and only secondarily the text that is the object's read syntax. Often there is no need to emphasize this distinction, but you must keep it in the back of your mind, or you will occasionally be very confused.

   Hash 表示法根本无法读取，因此每当遇到 “＃<” 时，Lisp reader 就会产生 invalid-read-syntax 错误。在其他语言中，表达是文本; 它没有其他形式。在 Lisp 中，表达式首先是一个 Lisp 对象，然后只是作为对象读取语法的文本。通常没有必要强调这种区别，但必须把它放在脑海中，否则偶尔会感到非常困惑。

   When you evaluate an expression interactively, the Lisp interpreter first reads the textual representation of it, producing a Lisp object, and then evaluates that object (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Evaluation.html#Evaluation][Evaluation]] ). However, evaluation and reading are separate activities. Reading returns the Lisp object represented by the text that is read; the object may or may not be evaluated later. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Input-Functions.html#Input-Functions][Input Functions]] , for a description of read, the basic function for reading objects。

   当以交互方式计算表达式时，Lisp 解释器首先读取它的文本表示，生成一个 Lisp 对象，然后计算该对象（请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Evaluation.html#Evaluation][Evaluation]] ）。但是，求值和阅读是单独的活动。读取返回由读取的文本表示的 Lisp 对象; 接下来该对象不一定会被求值。读取对象的基本功能是 read 函数，参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Input-Functions.html#Input-Functions][Input Functions]] 。

** 2.2 Comments（注释）
   A comment is text that is written in a program only for the sake of humans that read the program, and that has no effect on the meaning of the program. In Lisp, a semicolon (‘;’) starts a comment if it is not within a string or character constant. The comment continues to the end of line. The Lisp reader discards comments; they do not become part of the Lisp objects which represent the program within the Lisp system.

   注释是仅为了阅读程序的人而在程序中编写的文本，并且对程序的含义没有影响。 在 Lisp 中，不在字符串或字符常量内的分号（';'）开始注释，持续到行尾。Lisp reader 丢弃注释; 它们不会成为 Lisp 对象的一部分，后者代表 Lisp 系统中的程序。

   The ‘#@count’ construct, which skips the next count characters, is useful for program-generated comments containing binary data. The Emacs Lisp byte compiler uses this in its output files (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Byte-Compilation.html#Byte-Compilation][Byte Compilation]]). It isn't meant for source files, however.

   ‘#@count’结构，跳过接下来的 count 个字符，用于程序生成的包含二进制数据的注释。Emacs Lisp 字节编译器在其输入文件(see  [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Byte-Compilation.html#Byte-Compilation][Byte Compilation]])中使用这种结构。但是，它不适用于源文件。

   See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html#Comment-Tips][Comment Tips]] , for conventions for formatting comments.

   参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html#Comment-Tips][Comment Tips]] ，了解格式化注释的约定。

** 2.3 Programming Types（编程类型）

   There are two general categories of types in Emacs Lisp: those having to do with Lisp programming, and those having to do with editing. The former exist in many Lisp implementations, in one form or another. The latter are unique to Emacs Lisp.

   Emacs Lisp 中有两种常见类型：与 Lisp 编程有关的类型，以及与编辑有关的类型。前者以多种形式存在于许多 Lisp 实现中。 后者为 Emacs Lisp 独有。

   + Integer Type: Numbers without fractional parts.

     整型：没有小数部分的数字。

   + Floating-Point Type: Numbers with fractional parts and with a large range.

     浮点型：具有小数部分且具有大范围的数字。

   + Character Type: The representation of letters, numbers and control characters.

     字符类型：字母，数字和控制字符的表示。

   + Symbol Type: A multi-use object that refers to a function, variable, or property list, and has a unique identity.

     符号类型：一种多用途对象，它引用功能，变量或属性列表，并具有唯一标识。

   + Sequence Type: Both lists and arrays are classified as sequences.

     序列类型：列表和数组都被分类为序列。

   + Cons Cell Type: Cons cells, and lists (which are made from cons cells).

     缺点 cell 类型：缺点 cell 和列表（由缺陷 cell 组成）。

   + Array Type: Arrays include strings and vectors.

     数组类型：数组包括字符串和向量。

   + String Type: An (efficient) array of characters.

     字符串类型：一个（有效的）字符数组。

   + Vector Type: One-dimensional arrays.

     矢量类型：一维数组。

   + Char-Table Type: One-dimensional sparse arrays indexed by characters.

     Char-Table 类型：由字符索引的一维稀疏数组。

   + Bool-Vector Type: One-dimensional arrays of t or nil.

     Bool-Vector 类型：t 或 nil 的一维数组。

   + Hash Table Type: Super-fast lookup tables.

     哈希表类型：超快查找表。

   + Function Type: A piece of executable code you can call from elsewhere.

     函数型：可以从其他地方调用的一段可执行代码。

   + Macro Type: A method of expanding an expression into another expression, more fundamental but less pretty.

     宏类型：将表达式扩展为另一个表达式的方法，更基础但不优美。

   + Primitive Function Type: A function written in C, callable from Lisp.

     基元函数类型：用 C 语言编写的函数，可以从 Lisp 调用。

   + Byte-Code Type: A function written in Lisp, then compiled.

     字节代码类型：用 Lisp 编写，然后编译的函数。

   + Record Type: Compound objects with programmer-defined types.

     记录类型：具有程序员定义类型的复合对象。

   + Type Descriptors: Objects holding information about types.

     类型描述符：包含类型信息的对象。

   + Autoload Type: A type used for automatically loading seldom-used functions.

     自动加载类型：用于自动加载很少使用的函数的类型。

   + Finalizer Type: Runs code when no longer reachable.

     终结器类型：当不再可达时运行代码。

*** 2.3.1 Integer Type（整型）
    The range of values for an integer depends on the machine. The minimum range is −536,870,912 to 536,870,911 (30 bits; i.e., −2**29 to 2**29 − 1) but many machines provide a wider range. Emacs Lisp arithmetic functions do not check for integer overflow. Thus (1+ 536870911) is −536,870,912 if Emacs integers are 30 bits.

    整数的值范围取决于机器。最小范围是 -536,870,912 至 536,870,911（30 位; 即 -2**29 至 2**29-1），但许多机器提供更宽的范围。Emacs Lisp 算术函数不检查整数溢出。因此，如果 Emacs 整数是 30 位，则（1 + 536870911）是 -536,870,912。

    The read syntax for integers is a sequence of (base ten) digits with an optional sign at the beginning and an optional period at the end. The printed representation produced by the Lisp interpreter never has a leading ‘+’ or a final ‘.’.

    整数的读取语法是十进制数字的序列，在开头有一个可选的符号，在结尾有一个可选的句点。Lisp 解释器生成的打印表示从不具有前导 “+” 或最终 “.”。
    #+BEGIN_SRC elisp
-1               ; The integer −1.
1                ; The integer 1.
1.               ; Also the integer 1.
+1               ; Also the integer 1.
    #+END_SRC

    As a special exception, if a sequence of digits specifies an integer too large or too small to be a valid integer object, the Lisp reader reads it as a floating-point number (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Floating_002dPoint-Type.html#Floating_002dPoint-Type][Floating Point Type]]). For instance, if Emacs integers are 30 bits, 536870912 is read as the floating-point number 536870912.0.

    特殊例外，如果数字序列指定的整数太大或太小而不能成为有效的整数对象，则 Lisp reader 将其读取为浮点数（请参阅 ）。例如，如果 Emacs 整数是 30 位，则 536870912 被读取为浮点数 536870912.0。

    See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Numbers.html#Numbers][Numbers]], for more information.

    See Numbers 了解更多信息。

*** 2.3.2 Floating Point Type（浮点型）
    Floating point numbers are the computer equivalent of scientific notation; you can think of a floating point number as a fraction together with a power of ten. The precise number of significant figures and the range of possible exponents is machine-specific; Emacs uses the C data type double to store the value, and internally this records a power of 2 rather than a power of 10.

    浮点数是计算机等效的科学记数法; 可以把浮点数看作一个分数和 10 的幂。有效数字的精确数量和可能的指数范围是机器特定的; Emacs 使用 C 数据类型 double 来存储值，并在内部记录 2 的幂而不是 10 的幂。

    The printed representation for floating point numbers requires either a decimal point (with at least one digit following), an exponent, or both. For example, ‘1500.0’, ‘15e2’, ‘15.0e2’, ‘1.5e3’, and ‘.15e4’ are five ways of writing a floating point number whose value is 1500. They are all equivalent.

    浮点数的打印表示需要小数点（后跟至少一位数），指数或两者都有。例如，'1500.0'，'+ 15e2'，'15 .0e + 2'，'+ 1500000e-3'和'.15e4'是写入值为 1500 的浮点数的五种方法。它们都是等价的。

    See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Numbers.html#Numbers][Numbers]], for more information.

    See Numbers 了解更多信息。

*** 2.3.3 Character Type（字符型）

    A character in Emacs Lisp is nothing more than an integer. In other words, characters are represented by their character codes. For example, the character A is represented as the integer 65.
    Emacs Lisp 中的一个字符只不过是一个整数。 换句话说，字符由它们的字符代码表示。 例如，字符 A 表示为整数 65。

    Individual characters are used occasionally in programs, but it is more common to work with strings, which are sequences composed of characters. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/String-Type.html#String-Type][String Type]] .

    个别字符偶尔会在程序中使用，但更常见的是使用字符串，这些字符串是由字符组成的序列。 请参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/String-Type.html#String-Type][String Type]]

    Characters in strings and buffers are currently limited to the range of 0 to 4194303—twenty two bits (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Character-Codes.html#Character-Codes][Character Codes]] ). Codes 0 through 127 are ASCII codes; the rest are non-ASCII (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Non_002dASCII-Characters.html#Non_002dASCII-Characters][Non-ASCII Characters]] ). Characters that represent keyboard input have a much wider range, to encode modifier keys such as Control, Meta and Shift.

    字符串和缓冲区中的字符当前限制在 0 到 4194303 的范围内 - 二十二位（参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Character-Codes.html#Character-Codes][Character Codes]]）。 代码 0 到 127 是 ASCII 码;  其余为非 ASCII（请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Non_002dASCII-Characters.html#Non_002dASCII-Characters][Non-ASCII Characters]] ）。 表示键盘输入的字符具有更宽的范围，用于编码修饰键，例如 Control，Meta 和 Shift。

    There are special functions for producing a human-readable textual description of a character for the sake of messages. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Describing-Characters.html#Describing-Characters][Describing Characters]] .

    特殊函数可以产生人类可读的文本，这些文本用于描述消息相关的字符。 请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Describing-Characters.html#Describing-Characters][Describing Characters]] 。

    对于用来传递消息的字符，有特殊的函数来来生成人类可读的文本描述。

    + Basic Char Syntax: Syntax for regular characters.

      基本字符语法：常规字符的语法。

    + General Escape Syntax: How to specify characters by their codes.

      常规转义语法：如何通过代码指定字符。

    + Ctl-Char Syntax: Syntax for control characters.

    + Meta-Char Syntax: Syntax for meta-characters.

    + Other Char Bits: Syntax for hyper-, super-, and alt-characters.


**** 2.3.3.1 Basic Char Syntax（基本字符语法）
     Since characters are really integers, the printed representation of a character is a decimal number. This is also a possible read syntax for a character, but writing characters that way in Lisp programs is not clear programming. You should always use the special read syntax formats that Emacs Lisp provides for characters. These syntax formats start with a question mark.

     由于字符实际上是整数，因此字符的打印表示是十进制数。这也是字符可能的读取语法，但在 Lisp 程序中以这种方式编写字符并不是很清晰。应该始终使用 Emacs Lisp 为字符提供的特殊读取语法格式。这些语法格式以问号开头。

     The usual read syntax for alphanumeric characters is a question mark followed by the character; thus, ‘?A’ for the character A, ‘?B’ for the character B, and ‘?a’ for the character a.

     字母数字字符的通常读取语法是问号后跟字符; 因此，字符 A 对应'?A'，字符 B 对应'?B'，字符 a 对应'?a'。

     For example:

     例如：

     #+BEGIN_EXAMPLE
     ?Q ⇒ 81     ?q ⇒ 113
     #+END_EXAMPLE

     You can use the same syntax for punctuation characters. However, if the punctuation character has a special syntactic meaning in Lisp, you must quote it with a ‘\’. For example, ‘?\(’ is the way to write the open-paren character. Likewise, if the character is ‘\’, you must use a second ‘\’ to quote it: ‘?\\’.

     标点符号使用相同的语法。但是，如果标点符号在 Lisp 中具有特殊的句法含义，则必须使用'\'引用它。例如，'?\（'是 open-paren 字符的方法。同样，如果字符是'\'，你必须使用第二个'\'来引用它：'?\\'。

     You can express the characters control-g, backspace, tab, newline, vertical tab, formfeed, space, return, del, and escape as ‘?\a’, ‘?\b’, ‘?\t’, ‘?\n’, ‘?\v’, ‘?\f’, ‘?\s’, ‘?\r’, ‘?\d’, and ‘?\e’, respectively. (‘?\s’ followed by a dash has a different meaning—it applies the Super modifier to the following character.) Thus,

     可以将字符 control-g，backspace，tab，newline，vertical tab，formfeed，space，return，del 和 escape 分别表示为 ‘?\a’, ‘?\b’, ‘?\t’, ‘?\n’, ‘?\v’, ‘?\f’, ‘?\s’, ‘?\r’, ‘?\d’, and ‘?\e’,（'?\s'后面跟一个破折号有不同的含义-它将超级修饰符应用于下一个字符。）因此，

     #+BEGIN_EXAMPLE
     ?\a ⇒ 7                 ; control-g, C-g
     ?\b ⇒ 8                 ; backspace, <BS>, C-h
     ?\t ⇒ 9                 ; tab, <TAB>, C-i
     ?\n ⇒ 10                ; newline, C-j
     ?\v ⇒ 11                ; vertical tab, C-k
     ?\f ⇒ 12                ; formfeed character, C-l
     ?\r ⇒ 13                ; carriage return, <RET>, C-m
     ?\e ⇒ 27                ; escape character, <ESC>, C-[
     ?\s ⇒ 32                ; space character, <SPC>
     ?\\ ⇒ 92                ; backslash character, \
     ?\d ⇒ 127               ; delete character, <DEL>
     #+END_EXAMPLE

     These sequences which start with backslash are also known as escape sequences, because backslash plays the role of an escape character; this has nothing to do with the character <ESC>. ‘\s’ is meant for use in character constants; in string constants, just write the space.

     这些以反斜杠开头的序列也称为转义序列，因为反斜杠起着转义字符的作用; 这与 <ESC> 字符无关。'\s'用于字符常量; 在字符串常量中，只需写入空格即可。

     A backslash is allowed, and harmless, preceding any character without a special escape meaning; thus, ‘?\+’ is equivalent to ‘?+’. There is no reason to add a backslash before most characters. However, you must add a backslash before any of the characters ‘()[]\;"’, and you should add a backslash before any of the characters ‘|'`#.,’ to avoid confusing the Emacs commands for editing Lisp code. You can also add a backslash before whitespace characters such as space, tab, newline and formfeed. However, it is cleaner to use one of the easily readable escape sequences, such as ‘\t’ or ‘\s’, instead of an actual whitespace character such as a tab or a space. (If you do write backslash followed by a space, you should write an extra space after the character constant to separate it from the following text.)

     任何没有特殊转义意义的字符之前允许有反斜杠，并且这是无害的; 因此，'?\+'相当于'?+'。没有理由在大多数字符之前添加反斜杠。但是，必须在 =()[]\;"= 之前添加反斜杠，并且应该在 =|'`＃.,= 之前添加反斜杠，以避免编辑 Lisp 代码的 Emacs 命令会混淆。还可以在空格，制表符，换行符和换页符等空白字符之前添加反斜杠。但是，使用转义序列（例如'\t'或'\s'）代替一个实际的空白字符，例如制表符或空格，更易于读取的。（如果写反斜杠后跟一个空格，应该在字符常量后写一个额外的空格，将它与下面的文本分开。）

**** 2.3.3.2 General Escape Syntax（一般转义语法）
     In addition to the specific escape sequences for special important control characters, Emacs provides several types of escape syntax that you can use to specify non-ASCII text characters.

     除了特殊重要控制字符的特定转义序列之外，Emacs 还提供了几种类型的转义语法，可用于指定非 ASCII 文本字符。

     + You can specify characters by their Unicode names, if any. ?\N{NAME} represents the Unicode character named NAME. Thus, ‘?\N{LATIN SMALL LETTER A WITH GRAVE}’ is equivalent to ?à and denotes the Unicode character U+00E0. To simplify entering multi-line strings, you can replace spaces in the names by non-empty sequences of whitespace (e.g., newlines).

       可以按 Unicode 名称指定字符（如果有）。 =.?N{NAME}= 表示名为 NAME 的 Unicode 字符。因此， =‘?\N{LATIN SMALL LETTER A WITH GRAVE}’= 等同于 =?à= ，表示 Unicode 字符 U+00E0。要简化输入多行字符串，可以使用非空的空格序列（例如换行符）替换名称中的空格。

     + You can specify characters by their Unicode values. ?\N{U+X} represents a character with Unicode code point X, where X is a hexadecimal number. Also, ?\uxxxx and ?\Uxxxxxxxx represent code points xxxx and xxxxxxxx, respectively, where each x is a single hexadecimal digit. For example, ?\N{U+E0}, ?\u00e0 and ?\U000000E0 are all equivalent to ?à and to ‘?\N{LATIN SMALL LETTER A WITH GRAVE}’. The Unicode Standard defines code points only up to ‘U+10ffff’, so if you specify a code point higher than that, Emacs signals an error.

       可以通过 Unicode 值指定字符。 =?\N{U+X}= 表示具有 Unicode 代码点 X 的字符，其中 X 是十六进制数。此外，?\uxxxx 和 ?\Uxxxxxxxx 分别代表代码点 xxxx 和 xxxxxxxx，其中每个 x 是单个十六进制数字。例如，?\N{U+E0}，?\u00e0 和 ?\U000000E0 都等同于 ?à 和 '?\N{LATIN SMALL LETTER A WITH GRAVE}'。Unicode 标准仅将代码点定义为 “U+10ffff”，因此如果指定的代码点高于此值，则 Emacs 会发出错误信号。

     + You can specify characters by their hexadecimal character codes. A hexadecimal escape sequence consists of a backslash, ‘x’, and the hexadecimal character code. Thus, ‘?\x41’ is the character A, ‘?\x1’ is the character C-a, and ?\xe0 is the character à (a with grave accent). You can use any number of hex digits, so you can represent any character code in this way.

       可以按十六进制字符代码指定字符。十六进制转义序列由反斜杠 “x” 和十六进制字符代码组成。因此，'?\x41'对应字符 A，'?\x1'对应字符 C-a，而 ?\xe0 是字符 à（带有重音符号的 a）。可以使用任意数量的十六进制数字，这样您就可以用这种方式表示任何字符代码。

     + You can specify characters by their character code in octal. An octal escape sequence consists of a backslash followed by up to three octal digits; thus, ‘?\101’ for the character A, ‘?\001’ for the character C-a, and ?\002 for the character C-b. Only characters up to octal code 777 can be specified this way.

       可以按八进制字符代码指定字符。八进制转义序列由反斜杠后跟最多三个八进制数字组成; 因此，字符 A 的'?\101'，字符 C-a 的'?\001'和字符 C-b 的 ?\002。只能以这种方式指定最多为八进制代码 777 的字符。

     These escape sequences may also be used in strings. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Non_002dASCII-in-Strings.html#Non_002dASCII-in-Strings][Non-ASCII in Strings]].

     这些转义序列也可以用在字符串中。请参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Non_002dASCII-in-Strings.html#Non_002dASCII-in-Strings][Non-ASCII in Strings]]。

**** 2.3.3.3 Control-Character Syntax（控制字符语法）
     Control characters can be represented using yet another read syntax. This consists of a question mark followed by a backslash, caret, and the corresponding non-control character, in either upper or lower case. For example, both ‘?\^I’ and ‘?\^i’ are valid read syntax for the character C-i, the character whose value is 9.

     控制字符还可以用另一种读取语法来表示：包括一个问号，后跟反斜杠，插入符，以及相应的非控制字符（大写或小写）。例如， ‘?\^I’ 和 ‘?\^i’都是值是 9 的字符 C-i 的有效读取语法。

     Instead of the ‘^’, you can use ‘C-’; thus, ‘?\C-i’ is equivalent to ‘?\^I’ and to ‘?\^i’:

	 可用‘C-’替代‘^’， ‘?\C-i’ 等同于 ‘?\^I’ 以及 ‘?\^i’。
     #+BEGIN_EXAMPLE
?\^I ⇒ 9     ?\C-I ⇒ 9
     #+END_EXAMPLE

     In strings and buffers, the only control characters allowed are those that exist in ASCII; but for keyboard input purposes, you can turn any character into a control character with ‘C-’. The character codes for these non-ASCII control characters include the 2**26 bit as well as the code for the corresponding non-control character. Ordinary terminals have no way of generating non-ASCII control characters, but you can generate them straightforwardly using X and other window systems.

     在字符串和 buffer 中，只能使用 ASCII 中存在的存在的控制字符；是对于键盘输入，可以使用 “C-” 将任何字符转换为控制字符。这些非 ASCII 控制字符的字符代码包括 2**26 位以及相应非控制字符的代码。普通文本终端无法生成非 ASCII 控制字符，但可以使用 X 和其他窗口系统直接生成它们。

     For historical reasons, Emacs treats the <DEL> character as the control equivalent of ?:

	 由于历史的原因，Emacs 将<DEL>等价为 ? 的控制字符：
     #+BEGIN_EXAMPLE
?\^? ⇒ 127     ?\C-? ⇒ 127
     #+END_EXAMPLE

     As a result, it is currently not possible to represent the character Control-?, which is a meaningful input character under X, using ‘\C-’. It is not easy to change this, as various Lisp files refer to <DEL> in this way.

     因此，目前无法使用'\C-'来表示字符 Control-?, 前者是 X 下有意义的输入字符。改变它并不容易，因为各种 Lisp 文件以这种方式引用 <DEL>。

     For representing control characters to be found in files or strings, we recommend the ‘^’ syntax; for control characters in keyboard input, we prefer the ‘C-’ syntax. Which one you use does not affect the meaning of the program, but may guide the understanding of people who read it.

     文件或字符串中建议使用'^'语法表示控制字符; 使用'C-'语法代表键盘输入中的控制字符。使用哪一个不会影响该程序的理解，但可能会影响对阅读程序的人的理解。

	 代表在文件或字符串的控制字符，我们建议'^'语法，键盘输入的控制字符，我们更倾向于“C-”语法。使用哪一个都不影响程序的意义，但可能会指导那些阅读它的人理解它。

**** 2.3.3.4 Meta-Character Syntax

     A meta character is a character typed with the <META> modifier key. The integer that represents such a character has the 2**27 bit set. We use high bits for this and other modifiers to make possible a wide range of basic character codes.

     元字符是与 <META> 修饰键一起键入的字符。表示这样一个字符的整数设置为 2**27 位。 高位代表 meta 修饰符，其他位扩展为各种基本字符代码。

     In a string, the 2**7 bit attached to an ASCII character indicates a meta character; thus, the meta characters that can fit in a string have codes in the range from 128 to 255, and are the meta versions of the ordinary ASCII characters. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Strings-of-Events.html#Strings-of-Events][Strings of Events]], for details about <META>-handling in strings.

     字符串中，附加到 ASCII 字符的 2**7 位表示 meta 字符;  因此，可以放入字符串的元字符具有 128 到 255 范围内的代码，并且是普通 ASCII 字符的元版本。 有关 <META>- 字符串处理的详细信息，请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Strings-of-Events.html#Strings-of-Events][Strings of Events]]。

     The read syntax for meta characters uses ‘\M-’. For example, ‘?\M-A’ stands for M-A. You can use ‘\M-’ together with octal character codes (see below), with ‘\C-’, or with any other syntax for a character. Thus, you can write M-A as ‘?\M-A’, or as ‘?\M-\101’. Likewise, you can write C-M-b as ‘?\M-\C-b’, ‘?\C-\M-b’, or ‘?\M-\002’。

     元字符的读取语法使用'\M-'。 例如，'?\M-A'代表 M-A。 可以将'\M-'与八进制字符代码（见下文）'\ C-'或任何其他字符语法一起使用。 因此，可以将 M-A 写为 “?\ M-A” 或 “?\M- \101”。 同样，可以将 C-M-b 写为'?\M-\C-b'，'?\C-\M-b'或'?\M-\002'。

**** 2.3.3.5 Other Character Modifier Bits（其他字符修改位）
     The case of a graphic character is indicated by its character code; for example, ASCII distinguishes between the characters ‘a’ and ‘A’. But ASCII has no way to represent whether a control character is upper case or lower case. Emacs uses the 2**25 bit to indicate that the shift key was used in typing a control character. This distinction is possible only when you use X terminals or other special terminals; ordinary terminals do not report the distinction to the computer in any way. The Lisp syntax for the shift bit is ‘\S-’; thus, ‘?\C-\S-o’ or ‘?\C-\S-O’ represents the shifted-control-o character.

     图形字符由其字符代码表示; 例如，ASCII 区分字符'a'和'A'。但 ASCII 无法表示控制字符是大写还是小写。Emacs 使用 2**25 位来指示 Shift 键用于键入控制字符。只有在使用 X 端子或其他特殊端子时才能进行这种区分。普通文本终端不报告区别。Shift 位的 Lisp 语法是'\S-'; 因此，'？\C-\S-o'或'？\C-\S-O'代表 shift-control-o 字符。

     The X Window System defines three other modifier bits that can be set in a character: hyper, super and alt. The syntaxes for these bits are ‘\H-’, ‘\s-’ and ‘\A-’. (Case is significant in these prefixes.) Thus, ‘?\H-\M-\A-x’ represents Alt-Hyper-Meta-x. (Note that ‘\s’ with no following ‘-’ represents the space character.) Numerically, the bit values are 2**22 for alt, 2**23 for super and 2**24 for hyper.

     X Window 系统定义了三个其他修饰符位，可以在一个字符中设置：hyper，super 和 alt。这些位的语法是'\H-'，'\s-'和'\A-'。（这些前缀中大小写很重要。）因此，'？\H-\M-\A-x'代表 Alt-Hyper-Meta-x。 （注意'\s'没有跟随'-'表示空格字符。）从数值上看，alt 值为 2**22，super 为 2**23，hyper 为 2**24。

*** 2.3.4 Symbol Type（符号类型）
    A symbol in GNU Emacs Lisp is an object with a name. The symbol name serves as the printed representation of the symbol. In ordinary Lisp use, with one single obarray (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Symbols.html#Creating-Symbols][Creating Symbols]] ), a symbol's name is unique—no two symbols have the same name.

    GNU Emacs Lisp 中的符号是一个带有名称的对象。符号名称用作符号的打印表示。在普通的 Lisp 使用中，使用一个单引号（参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Symbols.html#Creating-Symbols][Creating Symbols]] ），符号的名称是唯一的，没有两个符号具有相同的名称。

    A symbol can serve as a variable, as a function name, or to hold a property list. Or it may serve only to be distinct from all other Lisp objects, so that its presence in a data structure may be recognized reliably. In a given context, usually only one of these uses is intended. But you can use one symbol in all of these ways, independently.

    符号可以用作变量，函数名称或保存属性列表。或者它可以仅用于区别于所有其他 Lisp 对象，从而其在数据结构中识别。在给定的上下文中，通常仅打算使用这些用途中的一种。但是可以独立地使用符号的所有这些方面。

    A symbol whose name starts with a colon (‘:’) is called a keyword symbol. These symbols automatically act as constants, and are normally used only by comparing an unknown symbol with a few specific alternatives. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Constant-Variables.html#Constant-Variables][Constant Variables]] .

    名称以冒号（':'）开头的符号称为关键字符号。这些符号自动充当常量，通常仅用于将未知符号与几个特殊的候选项比较。请参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Constant-Variables.html#Constant-Variables][Constant Variables]] 。

    A symbol name can contain any characters whatever. Most symbol names are written with letters, digits, and the punctuation characters ‘-+=*/’. Such names require no special punctuation; the characters of the name suffice as long as the name does not look like a number. (If it does, write a ‘\’ at the beginning of the name to force interpretation as a symbol.) The characters ‘_~!@$%^&:<>{}?’ are less often used but also require no special punctuation. Any other characters may be included in a symbol's name by escaping them with a backslash. In contrast to its use in strings, however, a backslash in the name of a symbol simply quotes the single character that follows the backslash. For example, in a string, ‘\t’ represents a tab character; in the name of a symbol, however, ‘\t’ merely quotes the letter ‘t’. To have a symbol with a tab character in its name, you must actually use a tab (preceded with a backslash). But it's rare to do such a thing.

    符号名称可以包含任何字符。大多数符号名称都使用字母，数字和标点符号'-+=*/'。这些名称不需要特殊的标点符号; 只要名称看起来不像数字就足够了。 （否则请在名称的开头写一个'\'以强制解释为符号。）字符 =_~!@$%^&:<>{}?= 不常使用，但也不需要特殊的标点符号。通过使用反斜杠转义符号的任何其他字符可以包含在符号的名称中。但是，与字符串中的使用相反，符号名称中的反斜杠只是引用反斜杠后面的单个字符。例如，在字符串中，'\t'表示制表符; 但是，在符号名称中，'\t'仅引用字母't'。要在其名称中包含带有制表符的符号，必须实际使用制表符（前面带有反斜杠）。但很少这么做。

    Common Lisp note: In Common Lisp, lower case letters are always “folded” to upper case, unless they are explicitly escaped. In Emacs Lisp, upper case and lower case letters are distinct.

    Common Lisp 注意：在 Common Lisp 中，小写字母总是折叠成大写字母，除非它们被显式转义。在 Emacs Lisp 中，大写和小写字母是不同的。

    Here are several examples of symbol names. Note that the ‘+’ in the fifth example is escaped to prevent it from being read as a number. This is not necessary in the fourth example because the rest of the name makes it invalid as a number.

    以下是符号名称的几个示例。请注意，第四个示例中的 “+” 是转义的，以防止将其作为数字读取。这在第六个示例中不必如此，因为名称的其余部分使其作为数字无效。

    #+BEGIN_SRC elisp
foo                 ; A symbol named ‘foo’.
FOO                 ; A symbol named ‘FOO’, different from ‘foo’.
1+                  ; A symbol named ‘1+’
                    ;   (not ‘+1’, which is an integer).
\+1                 ; A symbol named ‘+1’
                                        ;   (not a very readable name).
\(*\ 1\ 2\)         ; A symbol named ‘(* 1 2)’ (a worse name).


+-*/_~!@$%^&=:<>{}  ; A symbol named ‘+-*/_~!@$%^&=:<>{}’.
                                        ;   These characters need not be escaped.
    #+END_SRC

    As an exception to the rule that a symbol's name serves as its printed representation, ‘##’ is the printed representation for an interned symbol whose name is an empty string. Furthermore, ‘#:foo’ is the printed representation for an uninterned symbol whose name is foo. (Normally, the Lisp reader interns all symbols; see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Symbols.html#Creating-Symbols][Creating Symbols]] .)

    符号名称作为其打印表示，这条规则有个例外：“##” 是 interned symbol 的打印表示，其名称为空字符串。 此外，'＃:foo'是 uninterned symbol 的打印表示，其名称为 foo。 （通常，Lisp reader 会 intern 所有符号; 请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Symbols.html#Creating-Symbols][Creating Symbols]] 。）

*** 2.3.5 Sequence Types（序列类型）
    A sequence is a Lisp object that represents an ordered set of elements. There are two kinds of sequence in Emacs Lisp: lists and arrays.

    序列是一个 Lisp 对象，表示一组有序的元素。Emacs Lisp 中有两种序列：列表和数组。

    Lists are the most commonly-used sequences. A list can hold elements of any type, and its length can be easily changed by adding or removing elements. See the next subsection for more about lists.

    列表是最常用的序列。列表可以包含任何类型的元素，并且可以通过添加或删除元素轻松更改其长度。有关列表的更多信息，请参阅下一小节。

    Arrays are fixed-length sequences. They are further subdivided into strings, vectors, char-tables and bool-vectors. Vectors can hold elements of any type, whereas string elements must be characters, and bool-vector elements must be t or nil. Char-tables are like vectors except that they are indexed by any valid character code. The characters in a string can have text properties like characters in a buffer (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Properties.html#Text-Properties][Text Properties]] ), but vectors do not support text properties, even when their elements happen to be characters.

    数组是固定长度的序列。它们进一步细分为 strings, vectors, char-tables and bool-vectors。vector 可以包含任何类型的元素，而 string 元素必须是字符，而 bool-vector 元素必须是 t 或 nil。char-table 就像 vector，除了它们被任何有效的字符代码索引。string 中的字符可以具有文本属性，如缓冲区中的字符（请参阅  [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Properties.html#Text-Properties][Text Properties]] ），但 vector 不支持文本属性，即使它们的元素恰好是字符。

    Lists, strings and the other array types also share important similarities. For example, all have a length l, and all have elements which can be indexed from zero to l minus one. Several functions, called sequence functions, accept any kind of sequence. For example, the function length reports the length of any kind of sequence. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Sequences-Arrays-Vectors.html#Sequences-Arrays-Vectors][Sequences Arrays Vectors]].

    列表，字符串和其他数组类型也有重要的相似之处。例如，所有都具有长度 l，并且所有元素都具有可以从零到 l 减 1 的索引。一些序列函数接受任何类型的序列。例如，函数长度报告任何类型序列的长度。请参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Sequences-Arrays-Vectors.html#Sequences-Arrays-Vectors][Sequences Arrays Vectors]] 。

    It is generally impossible to read the same sequence twice, since sequences are always created anew upon reading. If you read the read syntax for a sequence twice, you get two sequences with equal contents. There is one exception: the empty list () always stands for the same object, nil.

    通常不可能读取相同的序列两次，因为序列总是在读取时重新创建。如果读取序列的读取语法两次，则会得到两个内容相等的序列。有一个例外：空列表()总是代表同一个对象 nil。

*** 2.3.6 Cons Cell and List Types（Cons Cell 和表类型）
    A cons cell is an object that consists of two slots, called the car slot and the cdr slot. Each slot can hold any Lisp object. We also say that the car of this cons cell is whatever object its car slot currently holds, and likewise for the cdr.

    cons cell 是由两个 slot 组成的对象，称为 car slot 和 cdr slot。每个 slot 都可以容纳任何 Lisp 对象。还可表述为这个 cons cell 的 car 是它的 car slot 目前所持有的任何物体，同样也可描述 cdr。

    A list is a series of cons cells, linked together so that the cdr slot of each cons cell holds either the next cons cell or the empty list. The empty list is actually the symbol nil. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Lisp-Data-Types.html#Lisp-Data-Types][Lists]] , for details. Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a list structure.

    列表是一系列 cons cell，链接在一起使得每个 cons cell 的 cdr slot 持有下一个 cons cell 或空列表。空列表实际上是符号 nil。详见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Lisp-Data-Types.html#Lisp-Data-Types][Lists]] 。因为大多数 cons cell 用作列表的一部分，所以将由 cons cell 构成的任何结构称为列表结构。

    A note to C programmers: a Lisp list thus works as a linked list built up of cons cells. Because pointers in Lisp are implicit, we do not distinguish between a cons cell slot holding a value versus pointing to the value.

    C 程序员的注意：Lisp 列表因此作为由 cons cell 构成的链表。因为 Lisp 中的指针是隐式的，所以我们不区分持有值的 cons cell 格 slot 与指向值的区别。

    Because cons cells are so central to Lisp, we also have a word for an object which is not a cons cell. These objects are called atoms.

    因为 cons cell 对 Lisp 来说是如此重要，所以不是 cons cell 的对象称为 atoms。

    The read syntax and printed representation for lists are identical, and consist of a left parenthesis, an arbitrary number of elements, and a right parenthesis. Here are examples of lists:

    列表的读取语法和打印表示是相同的，由左括号，任意数量的元素和右括号组成。以下是列表示例：

    #+BEGIN_SRC elisp
(A 2 "A")            ; A list of three elements.
()                   ; A list of no elements (the empty list).
nil                  ; A list of no elements (the empty list).
("A ()")             ; A list of one element: the string "A ()".
(A ())               ; A list of two elements: A and the empty list.
(A nil)              ; Equivalent to the previous.
((A B C))            ; A list of one element
                                        ;   (which is a list of three elements).

    #+END_SRC

    Upon reading, each object inside the parentheses becomes an element of the list. That is, a cons cell is made for each element. The car slot of the cons cell holds the element, and its cdr slot refers to the next cons cell of the list, which holds the next element in the list. The cdr slot of the last cons cell is set to hold nil.

    在读取时，括号内的每个对象都成为列表的元素。 也就是说，所有元素组成一个 cons cell。cons cell 的 car slot 保持元素，其 cdr slot 指向列表的下一个 cons cell，它保存列表中的下一个元素。 最后一个 cons cell 的 cdr slot 设置为 nil。

    The names car and cdr derive from the history of Lisp. The original Lisp implementation ran on an IBM 704 computer which divided words into two parts, the address and the decrement; car was an instruction to extract the contents of the address part of a register, and cdr an instruction to extract the contents of the decrement. By contrast, cons cells are named for the function cons that creates them, which in turn was named for its purpose, the construction of cells.

    名称 car 和 cdr 源自 Lisp 的历史。 原始的 Lisp 实现在 IBM 704 计算机上运行，该计算机将单词分为两部分，即地址和减量; car 是用于提取寄存器的地址部分的内容的指令，并且 cdr 用于提取递减的内容的指令。 相比之下，cons cell 以创建它们的函数 cons 命名，而函数 cons 用来构造 cell。

    + Box Diagrams: Drawing pictures of lists.

      方框图：绘制列表图片。

    + Dotted Pair Notation: A general syntax for cons cells.

      虚线对表示法：cons cell 的一般语法。

    + Association List Type: A specially constructed list.

      关联列表类型：特殊构造的列表。

**** 2.3.6.1 Drawing Lists as Box Diagrams
     A list can be illustrated by a diagram in which the cons cells are shown as pairs of boxes, like dominoes. (The Lisp reader cannot read such an illustration; unlike the textual notation, which can be understood by both humans and computers, the box illustrations can be understood only by humans.) This picture represents the three-element list (rose violet buttercup):

     列表可以通过图表来说明，其中 cons cell 显示为多对盒子，如多米诺骨牌。 （Lisp reader 无法阅读这样的插图; 与人类和计算机都能理解的文本符号不同，盒子插图只能由人类理解。）这张图片代表三元素列表 =(rose violet buttercup)= ：

     #+BEGIN_EXAMPLE
 --- ---      --- ---      --- ---
|   |   |--> |   |   |--> |   |   |--> nil
 --- ---      --- ---      --- ---
  |            |            |
  |            |            |
   --> rose     --> violet   --> buttercup
     #+END_EXAMPLE

     In this diagram, each box represents a slot that can hold or refer to any Lisp object. Each pair of boxes represents a cons cell. Each arrow represents a reference to a Lisp object, either an atom or another cons cell.

     在此图中，每个框表示一个可以保存或引用任何 Lisp 对象的 slot。 每对盒子代表一个 cons cell。 每个箭头表示对 Lisp 对象的引用，无论是 atoms 还是其他 cons cell。

     In this example, the first box, which holds the car of the first cons cell, refers to or “holds” rose (a symbol). The second box, holding the cdr of the first cons cell, refers to the next pair of boxes, the second cons cell. The car of the second cons cell is violet, and its cdr is the third cons cell. The cdr of the third (and last) cons cell is nil.

     在该示例中，第一个框持有 cons cell 的 car，即 rose（符号）。 第二个框持有第一个 cons cell 格的 cdr，指的是下一对框，即第二个 cons cell。 第二个 cons cell 的 car 是 violet，它的 cdr 是第三个 cons cell。 第三个（也是最后一个）cons cell 的 cdr 为 nil。

     Here is another diagram of the same list, (rose violet buttercup), sketched in a different manner:

     这是同一列表的另一个图表，(rose violet buttercup)，用不同的方式勾勒出来：

     #+BEGIN_EXAMPLE
      ---------------       ----------------       -------------------
     | car   | cdr   |     | car    | cdr   |     | car       | cdr   |
     | rose  |   o-------->| violet |   o-------->| buttercup |  nil  |
     |       |       |     |        |       |     |           |       |
      ---------------       ----------------       -------------------
     #+END_EXAMPLE


     A list with no elements in it is the empty list; it is identical to the symbol nil. In other words, nil is both a symbol and a list.

     没有元素的表称是空表；它等同于符号 nil。换句话说，nil 既是符号，又是列表。

     Here is the list (A ()), or equivalently (A nil), depicted with boxes and arrows:

     下面是表(A ())，或者等价的(A nil)，由盒子和箭头描绘：

     #+BEGIN_EXAMPLE
         --- ---      --- ---
        |   |   |--> |   |   |--> nil
         --- ---      --- ---
          |            |
          |            |
           --> A        --> nil
     #+END_EXAMPLE


     Here is a more complex illustration, showing the three-element list, ((pine needles) oak maple), the first element of which is a two-element list:

     这是一个更复杂的插图，显示了三元素列表((pine needles) oak maple)，其中第一个元素是两元素列表：

     #+BEGIN_EXAMPLE
         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
          |             --> oak      --> maple
          |
          |     --- ---      --- ---
           --> |   |   |--> |   |   |--> nil
                --- ---      --- ---
                 |            |
                 |            |
                  --> pine     --> needles
     #+END_EXAMPLE

     The same list represented in the second box notation looks like this:

     第二个框表示法中表示的相同列表如下所示：

     #+BEGIN_EXAMPLE
      --------------       --------------       --------------
     | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
     |   o   |   o------->| oak   |   o------->| maple |  nil |
     |   |   |      |     |       |      |     |       |      |
      -- | ---------       --------------       --------------
         |
         |
         |        --------------       ----------------
         |       | car   | cdr  |     | car     | cdr  |
          ------>| pine  |   o------->| needles |  nil |
                 |       |      |     |         |      |
     #+END_EXAMPLE


**** 2.3.6.2 Dotted Pair Notation（点对记法）
     Dotted pair notation is a general syntax for cons cells that represents the car and cdr explicitly. In this syntax, (a . b) stands for a cons cell whose car is the object a and whose cdr is the object b. Dotted pair notation is more general than list syntax because the cdr does not have to be a list. However, it is more cumbersome in cases where list syntax would work. In dotted pair notation, the list ‘(1 2 3)’ is written as ‘(1 . (2 . (3 . nil)))’. For nil-terminated lists, you can use either notation, but list notation is usually clearer and more convenient. When printing a list, the dotted pair notation is only used if the cdr of a cons cell is not a list.

     点对记法是 cons cell 的一般语法，它明确表示 car 和 cdr。 在这种语法中，（a.b）代表一个 cons cel，car 是对象 a，cdr 是对象 b。 点对记法比列表语法更通用，因为 cdr 不必是列表。 但是，在列表语法可行的情况下，它更麻烦。 在点对表示法中，列表 =(1 2 3)= 写作 =(1 . (2 . (3 . nil)))= 。 对于 nil 终止的列表，可以使用任何一种表示法，但列表表示法通常更清晰，更方便。 打印列表时，仅 cons cell 的 cdr 不是列表时才使用点对记法。

     Here's an example using boxes to illustrate dotted pair notation. This example shows the pair (rose . violet):

     下面是用盒子演示点对记法的一个例子。此例子显示点对(rose . violet)：

     #+BEGIN_EXAMPLE
         --- ---
        |   |   |--> violet
         --- ---
          |
          |
           --> rose

     #+END_EXAMPLE

     You can combine dotted pair notation with list notation to represent conveniently a chain of cons cells with a non-nil final cdr. You write a dot after the last element of the list, followed by the cdr of the final cons cell. For example, (rose violet . buttercup) is equivalent to (rose . (violet . buttercup)). The object looks like this:

     可以将点对符号与列表表示法结合使用，以便方便地表示最后一个 cdr 不是 nil 的 cons cell 链。在列表的最后一个元素之后写一个点，然后是最后一个 cons cell 的 cdr。例如，(rose violet . buttercup) 等同于 (code . (violet . buttercup))，如下所示

     #+BEGIN_EXAMPLE
         --- ---      --- ---
        |   |   |--> |   |   |--> buttercup
         --- ---      --- ---
          |            |
          |            |
           --> rose     --> violet
     #+END_EXAMPLE


     The syntax (rose . violet . buttercup) is invalid because there is nothing that it could mean. If anything, it would say to put buttercup in the cdr of a cons cell whose cdr is already used for violet.

     语法(rose . violet . buttercup) 是无效的，因为它没有任何意义。如果非要说明其意义的话，可以说将 buttercup 放至 一个 cons cell 的 cdr 中，而该 cons cell 是 violet 的 cdr。

     The list (rose violet) is equivalent to (rose . (violet)), and looks like this:

     列表(rose violet) 等同 (rose . (violet))，它看起来如下所示：

     #+BEGIN_EXAMPLE
         --- ---      --- ---
        |   |   |--> |   |   |--> nil
         --- ---      --- ---
          |            |
          |            |
           --> rose     --> violet
     #+END_EXAMPLE

     Similarly, the three-element list (rose violet buttercup) is equivalent to (rose . (violet . (buttercup))). It looks like this:

	 相似地，三元素表(rose violet buttercup) 等同 (rose . (violet . buttercup)等价。 它看起来如下所示：

     #+BEGIN_EXAMPLE
         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup
     #+END_EXAMPLE

**** 2.3.6.3 Association List Type（关联列表类型）
     An association list or alist is a specially-constructed list whose elements are cons cells. In each element, the car is considered a key, and the cdr is considered an associated value. (In some cases, the associated value is stored in the car of the cdr.) Association lists are often used as stacks, since it is easy to add or remove associations at the front of the list.

     关联列表或 alist 是特殊构造的列表，其元素是 cons cell。 在每个元素里，car 被当作一个关键字，而 cdr 当作关联值。（某些情况下，关联值存储在 cdr 的 car 中。）关联列表通常用作堆栈，因为很容易在列表的前面添加或删除关联。

     For example,

     例如：

     #+BEGIN_SRC elisp
(setq alist-of-colors
      '((rose . red) (lily . white) (buttercup . yellow)))
     #+END_SRC

     sets the variable alist-of-colors to an alist of three elements. In the first element, rose is the key and red is the value.

     讲变量 alist-of-colors 设置为三个元素的关联表。在第一个元素中，rose 是 key，red 是 value。

     See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html#Association-Lists][Association Lists]] , for a further explanation of alists and for functions that work on alists. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Hash-Tables.html#Hash-Tables][Hash Tables]] , for another kind of lookup table, which is much faster for handling a large number of keys.

     有关 alist 和有关 alist 的函数的进一步说明参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html#Association-Lists][Association Lists]] 。有关另一种查找表，请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Hash-Tables.html#Hash-Tables][Hash Tables]] ，它对于处理大量键来说要快得多。

*** 2.3.7 Array Type
    An array is composed of an arbitrary number of slots for holding or referring to other Lisp objects, arranged in a contiguous block of memory. Accessing any element of an array takes approximately the same amount of time. In contrast, accessing an element of a list requires time proportional to the position of the element in the list. (Elements at the end of a list take longer to access than elements at the beginning of a list.)

    数组由任意数量的 slot 组成，用于保持或引用其他 Lisp 对象，这些对象排列在连续的存储块中。访问数组的任何元素所花费的时间大致相同。相反，访问列表的元素需要的实践与列表中元素的位置成正比。 （列表末尾的元素比列表开头的元素需要更长的时间。）

    Emacs defines four types of array: strings, vectors, bool-vectors, and char-tables.

    Emacs 定义了四种类型的数组：strings, vectors, bool-vectors, and char-tables。

    A string is an array of characters and a vector is an array of arbitrary objects. A bool-vector can hold only t or nil. These kinds of array may have any length up to the largest integer. Char-tables are sparse arrays indexed by any valid character code; they can hold arbitrary objects.

    string 是一个字符数组，vector 是任意对象的数组。bool-vector 只能保持 t 或 nil。这些类型的数组可以具有任何长度，直到最大整数。Char-table 是由任何有效字符代码索引的稀疏数组; 可以容纳任意对象。

    The first element of an array has index zero, the second element has index 1, and so on. This is called zero-origin indexing. For example, an array of four elements has indices 0, 1, 2, and 3. The largest possible index value is one less than the length of the array. Once an array is created, its length is fixed.

    数组的第一个元素的索引为零，第二个元素的索引为 1，依此类推。这称为零原点索引。例如，四个元素的数组具有索引 0,1,2 和 3. 最大可能的索引值比数组的长度小 1。创建数组后，其长度是固定的。

    All Emacs Lisp arrays are one-dimensional. (Most other programming languages support multidimensional arrays, but they are not essential; you can get the same effect with nested one-dimensional arrays.) Each type of array has its own read syntax; see the following sections for details.

    所有 Emacs Lisp 数组都是一维的。 （大多数其他编程语言都支持多维数组，但它们并不重要; 可以使用嵌套的一维数组获得相同的效果。）每种类型的数组都有自己的读取语法; 有关详细信息，请参阅以下部分

    The array type is a subset of the sequence type, and contains the string type, the vector type, the bool-vector type, and the char-table type.

    数组类型是序列类型的子集，包含 string 类型，vector 类型，bool-vector 类型和 char-table 类型。

*** 2.3.8 String Type
    A string is an array of characters. Strings are used for many purposes in Emacs, as can be expected in a text editor; for example, as the names of Lisp symbols, as messages for the user, and to represent text extracted from buffers. Strings in Lisp are constants: evaluation of a string returns the same string.

    字符串是一个字符数组。 字符串在 Emacs 中用处很多，可用于文本编辑器;  例如，作为 Lisp 符号的名称，作为用户的消息，以及表示从缓冲区中提取的文本。Lisp 中的字符串是常量：字符串的求值返回相同的字符串。

    See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Strings-and-Characters.html#Strings-and-Characters][Strings and Characters]] , for functions that operate on strings.

    有关对字符串进行操作的函数，请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Strings-and-Characters.html#Strings-and-Characters][Strings and Characters]] 。

    + Syntax for Strings: How to specify Lisp strings.

      字符串的语法：如何指定 Lisp 字符串。

    + Non-ASCII in Strings: International characters in strings.

      字符串中的非 ASCII：字符串中的国际字符。

    + Nonprinting Characters: Literal unprintable characters in strings.

      非打印字符：字符串中的文字不可打印字符。

    + Text Props and Strings: Strings with text properties.

      文本道具和字符串：具有文本属性的字符串。

**** 2.3.8.1 Syntax for Strings
     The read syntax for a string is a double-quote, an arbitrary number of characters, and another double-quote, "like this". To include a double-quote in a string, precede it with a backslash; thus, "\"" is a string containing just one double-quote character. Likewise, you can include a backslash by preceding it with another backslash, like this: "this \\ is a single embedded backslash".

     字符串的读取语法是双引号中的任意数量的字符，“like this”。要在字符串中包含双引号，请在其前面加上反斜杠; 因此，“\"“是一个只包含一个双引号字符的字符串。同样，可以在前面加上另一个反斜杠包含一个反斜杠，如下所示："this \\ is a single embedded backslash" 。

     The newline character is not special in the read syntax for strings; if you write a new line between the double-quotes, it becomes a character in the string. But an escaped newline—one that is preceded by ‘\’—does not become part of the string; i.e., the Lisp reader ignores an escaped newline while reading a string. An escaped space ‘\ ’ is likewise ignored.

     换行符在字符串的读取语法中并不特殊; 如果在双引号之间写一个新行，它将成为字符串中的一个字符。但是一个转义的换行符 - 前面带有'\'换行不会成为字符串的一部分; 即，Lisp reader 在读取字符串时忽略转义的换行符。转义空格'\'同样被忽略。

     #+BEGIN_EXAMPLE
      "It is useful to include newlines
      in documentation strings,
      but the newline is \
      ignored if escaped."
           ⇒ "It is useful to include newlines
      in documentation strings,
      but the newline is ignored if escaped."

     #+END_EXAMPLE

**** 2.3.8.2 Non-ASCII Characters in Strings
     There are two text representations for non-ASCII characters in Emacs strings: multibyte and unibyte (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Representations.html#Text-Representations][Text Representations]] ). Roughly speaking, unibyte strings store raw bytes, while multibyte strings store human-readable text. Each character in a unibyte string is a byte, i.e., its value is between 0 and 255. By contrast, each character in a multibyte string may have a value between 0 to 4194303 (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Character-Type.html#Character-Type][Character Type]] ). In both cases, characters above 127 are non-ASCII.

     Emacs 字符串中的非 ASCII 字符有两种文本表示形式：multibyte 和 unibyte（请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Representations.html#Text-Representations][Text Representations]] ）。粗略地说，unibyte 字符串存储原始字节，而多字节字符串存储人类可读的文本。unibyte 字符串中的每个字符都是一个字节，即其​​值介于 0 到 255 之间。相反，多字节字符串中的每个字符的值可能介于 0 到 4194303 之间（请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Character-Type.html#Character-Type][Character Type]] ）。在这两种情况下，127 以上的字符都是非 ASCII。

     You can include a non-ASCII character in a string constant by writing it literally. If the string constant is read from a multibyte source, such as a multibyte buffer or string, or a file that would be visited as multibyte, then Emacs reads each non-ASCII character as a multibyte character and automatically makes the string a multibyte string. If the string constant is read from a unibyte source, then Emacs reads the non-ASCII character as unibyte, and makes the string unibyte.

     可通过字符串常量在字符串中包含非 ASCII 字符。如果从多字节源（例如多字节缓冲区或字符串）或将作为多字节访问的文件中读取字符串常量，则 Emacs 将每个非 ASCII 字符作为多字节字符读取，并自动使字符串成为多字节字符串。如果从 unibyte 源读取字符串常量，则 Emacs 将非 ASCII 字符读取为 unibyte，并使字符串为 unibyte。

     Instead of writing a character literally into a multibyte string, you can write it as its character code using an escape sequence. See General Escape Syntax, for details about [[https://www.gnu.org/software/emacs/manual/html_node/elisp/General-Escape-Syntax.html#General-Escape-Syntax][escape sequences]] .

     可以使用转义序列将其写为字符代码，而不是将字符字面写入多字节字符串。有关转义序列的详细信息，请参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/General-Escape-Syntax.html#General-Escape-Syntax][escape sequences]] 。

     If you use any Unicode-style escape sequence ‘\uNNNN’ or ‘\U00NNNNNN’ in a string constant (even for an ASCII character), Emacs automatically assumes that it is multibyte.

     如果在字符串常量中使用任何 Unicode 样式的转义序列'\uNNNN'或'\U00NNNNNN'（即使对于 ASCII 字符），Emacs 会自动假定它是多字节的。

     You can also use hexadecimal escape sequences (‘\xn’) and octal escape sequences (‘\n’) in string constants. But beware: If a string constant contains hexadecimal or octal escape sequences, and these escape sequences all specify unibyte characters (i.e., less than 256), and there are no other literal non-ASCII characters or Unicode-style escape sequences in the string, then Emacs automatically assumes that it is a unibyte string. That is to say, it assumes that all non-ASCII characters occurring in the string are 8-bit raw bytes.

     还可以在字符串常量中使用十六进制转义序列（'\xn'）和八进制转义序列（'\n'）。但要注意：如果字符串常量包含十六进制或八进制转义序列，并且这些转义序列都指定 unibyte 字符（即小于 256），并且字符串中没有其他文字非 ASCII 字符或 Unicode 样式的转义序列，然后 Emacs 自动假定它是 unibyte 字符串。也就是说，它假定字符串中出现的所有非 ASCII 字符都是 8 位原始字节。

     In hexadecimal and octal escape sequences, the escaped character code may contain a variable number of digits, so the first subsequent character which is not a valid hexadecimal or octal digit terminates the escape sequence. If the next character in a string could be interpreted as a hexadecimal or octal digit, write ‘\ ’ (backslash and space) to terminate the escape sequence. For example, ‘\xe0\ ’ represents one character, ‘a’ with grave accent. ‘\ ’ in a string constant is just like backslash-newline; it does not contribute any character to the string, but it does terminate any preceding hex escape.

     在十六进制和八进制转义序列中，转义字符代码可能包含可变数量的数字，因此第一个后续字符不是有效的十六进制或八进制数字会终止转义序列。如果字符串中的下一个字符可以解释为十六进制或八进制数字，则写入'\ '（反斜杠和空格）以终止转义序列。例如，'\xe0\ '表示一个带有重音符号的字符'a'。字符串常量中的'\ '就像反斜杠换行符一样; 它不会为字符串提供任何字符，但它会终止任何前面的十六进制转义。

**** 2.3.8.3 Nonprinting Characters in Strings
     You can use the same backslash escape-sequences in a string constant as in character literals (but do not use the question mark that begins a character constant). For example, you can write a string containing the nonprinting characters tab and C-a, with commas and spaces between them, like this: "\t, \C-a". See Character Type, for a description of the read syntax for characters.

     可以在字符串常量中使用与字符文字相同的反斜杠转义序列（但不要使用问号开始字符常量）。例如，您可以编写一个包含非打印字符选项卡和 C-a 的字符串，它们之间带有逗号和空格，如下所示：“\ t，\ C-a”。有关字符的读取语法的说明，请参阅字符类型。

     However, not all of the characters you can write with backslash escape-sequences are valid in strings. The only control characters that a string can hold are the ASCII control characters. Strings do not distinguish case in ASCII control characters.

     但是，并非所有使用反斜杠转义序列编写的字符在字符串中都有效。字符串可以容纳的唯一控制字符是 ASCII 控制字符。字符串不区分 ASCII 控制字符中的大小写。

     Properly speaking, strings cannot hold meta characters; but when a string is to be used as a key sequence, there is a special convention that provides a way to represent meta versions of ASCII characters in a string. If you use the ‘\M-’ syntax to indicate a meta character in a string constant, this sets the 2**7 bit of the character in the string. If the string is used in define-key or lookup-key, this numeric code is translated into the equivalent meta character. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Character-Type.html#Character-Type][Character Type]] .

     正确地说，字符串不能包含元字符; 但是当一个字符串用作键序列时，有一个特殊的约定，它提供了一种在字符串中表示 ASCII 字符的元版本的方法。如果使用'\M-'语法指示字符串常量中的元字符，则设置字符串中字符的 2**7 位。如果在 define-key 或 lookup-key 中使用该字符串，则此数字代码将转换为等效的元字符。参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Character-Type.html#Character-Type][Character Type]] 。

     Strings cannot hold characters that have the hyper, super, or alt modifiers.

     字符串不能包含 hyper, super, or alt 修饰符。

**** 2.3.8.4 Text Properties in Strings（字符串中的文本属性）
     A string can hold properties for the characters it contains, in addition to the characters themselves. This enables programs that copy text between strings and buffers to copy the text's properties with no special effort. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Properties.html#Text-Properties][Text Properties]] , for an explanation of what text properties mean. Strings with text properties use a special read and print syntax:

     除了字符本身之外，字符串还可以包含其字符属性。这使得在字符串和缓冲区之间复制文本的程序可以毫不费力地复制文本的属性。有关文本属性的含义的说明，请参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Properties.html#Text-Properties][Text Properties]] 。具有文本属性的字符串使用特殊的读取和打印语法：
     #+BEGIN_EXAMPLE
#("characters" property-data...)
     #+END_EXAMPLE

     where property-data consists of zero or more elements, in groups of three as follows:

     其中 property-data 由零个或多个元素组成，元素包含三个部分：
     #+BEGIN_EXAMPLE
beg end plist
     #+END_EXAMPLE

     The elements beg and end are integers, and together specify a range of indices in the string; plist is the property list for that range. For example,

     元素 beg 和 end 是整数，并且一起指定字符串中的范围; plist 是该范围的属性列表。例如，

     #+BEGIN_EXAMPLE
#("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))
     #+END_EXAMPLE

     represents a string whose textual contents are ‘foo bar’, in which the first three characters have a face property with value bold, and the last three have a face property with value italic. (The fourth character has no text properties, so its property list is nil. It is not actually necessary to mention ranges with nil as the property list, since any characters not mentioned in any range will default to having no properties.)

     表示文本内容为'foo bar'的字符串，其中前三个字符的 face 属性值为粗体，后三个字符的 face 属性值为 italic。 （第四个字符没有文本属性，因此其属性列表为 nil。实际上并不需要提及以 nil 作为属性列表的范围，因为任何范围中未提及的任何字符都将默认为没有属性。）

*** 2.3.9 Vector Type
    A vector is a one-dimensional array of elements of any type. It takes a constant amount of time to access any element of a vector. (In a list, the access time of an element is proportional to the distance of the element from the beginning of the list.)

    vector 是任何类型的元素的一维数组。访问向量的任何元素需要花费常量的时间。 （在列表中，元素的访问时间与元素与列表开头的距离成正比。）

    The printed representation of a vector consists of a left square bracket, the elements, and a right square bracket. This is also the read syntax. Like numbers and strings, vectors are considered constants for evaluation.

    vector 的打印表示由左方括号，元素和右方括号组成。这也是读取语法。与数字和字符串一样，vector 被当做常量求值。

    #+BEGIN_EXAMPLE
     [1 "two" (three)]      ; A vector of three elements.
          ⇒ [1 "two" (three)]

    #+END_EXAMPLE

    See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Sequences-Arrays-Vectors.html#Sequences-Arrays-Vectors][Vectors]], for functions that work with vectors.

    有关使用向量的函数，参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Sequences-Arrays-Vectors.html#Sequences-Arrays-Vectors][Vectors]]。

*** 2.3.10 Char-Table Type
    A char-table is a one-dimensional array of elements of any type, indexed by character codes. Char-tables have certain extra features to make them more useful for many jobs that involve assigning information to character codes—for example, a char-table can have a parent to inherit from, a default value, and a small number of extra slots to use for special purposes. A char-table can also specify a single value for a whole character set.

    char-table 是任何类型的一维元素数组，由字符代码索引。Char-table 有一些额外的功能，使它们对于涉及为字符代码分配信息的许多作业更有用-例如，char-table 可以继承，有默认值和少量额外的 slot 到 用于特殊目的。char-table 也可以为整个字符集指定单个值。

    The printed representation of a char-table is like a vector except that there is an extra ‘#^’ at the beginning.[fn:1]

    char-table 的打印表示就像一个向量，除了在开头有一个额外的'＃^'

    有关在 char 表上操作的特殊函数，请参见 Char-Tables。char 表的使用包括：

    See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Char_002dTables.html#Char_002dTables][Char-Tables]] , for special functions to operate on char-tables. Uses of char-tables include:

    有关在 char-table 上操作的特殊函数，请参见  [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Char_002dTables.html#Char_002dTables][Char-Tables]] 。Char-Tables 的使用包括：

    + Case tables (see Case Tables).

      案例表（见案例表）。

    + Character category tables (see Categories).

      字符类别表（见类别）。

    + Display tables (see Display Tables).

      显示表（参见显示表）。

    + Syntax tables (see Syntax Tables).

      语法表（请参见语法表）。

*** 2.3.11 Bool-Vector Type
    A bool-vector is a one-dimensional array whose elements must be t or nil.

    bool-vector 是一维数组，其元素必须为 t 或 nil。

    The printed representation of a bool-vector is like a string, except that it begins with ‘#&’ followed by the length. The string constant that follows actually specifies the contents of the bool-vector as a bitmap—each character in the string contains 8 bits, which specify the next 8 elements of the bool-vector (1 stands for t, and 0 for nil). The least significant bits of the character correspond to the lowest indices in the bool-vector.

    bool-vector 的打印表示形式类似于字符串，除了它以 “#&” 开头，后跟长度。后面的常量字符串实际上将 bool-vector 的内容显示为位图 - 字符串中的每个字符都包含 8 位，它指定 bool-vector 的接下来点对 8 个元素（1 代表 t，0 代表 nil）。字符的最低有效位对应于 bool-vector 中的最低索引。

    #+BEGIN_EXAMPLE
     (make-bool-vector 3 t)
          ⇒ #&3"^G"
     (make-bool-vector 3 nil)
          ⇒ #&3"^@"
    #+END_EXAMPLE

    These results make sense, because the binary code for ‘C-g’ is 111 and ‘C-@’ is the character with code 0.

    这些结果是有意义的，因为'C-g'的二进制代码是 111 而'C- @'是代码为 0 的字符。

    If the length is not a multiple of 8, the printed representation shows extra elements, but these extras really make no difference. For instance, in the next example, the two bool-vectors are equal, because only the first 3 bits are used:

    如果长度不是 8 的倍数，则打印的表示显示额外的元素，但这些额外的内容确实没有区别。例如，在下一个示例中，两个 bool 向量相等，因为只使用了前 3 位：

    #+BEGIN_EXAMPLE
     (equal #&3"\377" #&3"\007")
          ⇒ t
    #+END_EXAMPLE

*** 2.3.12 Hash Table Type
    A hash table is a very fast kind of lookup table, somewhat like an alist in that it maps keys to corresponding values, but much faster. The printed representation of a hash table specifies its properties and contents, like this:

    哈希表是一种非常快速的查找表，有点像 alist，因为它将键映射到相应的值，但速度要快得多。 哈希表的打印表示指定其属性和内容，如下所示：

    #+BEGIN_EXAMPLE
     (make-hash-table)
          ⇒ #s(hash-table size 65 test eql rehash-size 1.5
                                  rehash-threshold 0.8125 data ())
    #+END_EXAMPLE

    See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Hash-Tables.html#Hash-Tables][Hash Tables]] , for more information about hash tables.

*** 2.3.13 Function Type
    Lisp functions are executable code, just like functions in other programming languages. In Lisp, unlike most languages, functions are also Lisp objects. A non-compiled function in Lisp is a lambda expression: that is, a list whose first element is the symbol lambda (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Lambda-Expressions.html#Lambda-Expressions][Lambda Expressions]] ).

    Lisp 函数是可执行代码，就像其他编程语言中的函数一样。 在 Lisp 中，与大多数语言不同，函数也是 Lisp 对象。Lisp 中的一个非编译函数是一个 lambda 表达式：即一个列表，其第一个元素是符号 lambda（参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Lambda-Expressions.html#Lambda-Expressions][Lambda Expressions]] ）。

    In most programming languages, it is impossible to have a function without a name. In Lisp, a function has no intrinsic name. A lambda expression can be called as a function even though it has no name; to emphasize this, we also call it an anonymous function (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Anonymous-Functions.html#Anonymous-Functions][Anonymous Functions]] ). A named function in Lisp is just a symbol with a valid function in its function cell (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Defining-Functions.html#Defining-Functions][Defining Functions]] ).

    在大多数编程语言中，没有名称的函数是不可能的。 在 Lisp 中，函数没有内在名称。lambda 表达式可以作为函数调用，即使它没有名称;  为了强调这一点，也将其称为匿名函数（请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Anonymous-Functions.html#Anonymous-Functions][Anonymous Functions]] ）。Lisp 中的命名函数只是在其函数单元中具有有效函数的符号（请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Defining-Functions.html#Defining-Functions][Defining Functions]] ）。

    Most of the time, functions are called when their names are written in Lisp expressions in Lisp programs. However, you can construct or obtain a function object at run time and then call it with the primitive functions funcall and apply. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Calling-Functions.html#Calling-Functions][Calling Functions]].

    大多数情况下，函数在 Lisp 程序中 Lisp 表达式包含函数名时调用。 但是，可以在运行时构造或获取函数对象，然后使用基本函数 funcall 和 apply 调用它。 请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Calling-Functions.html#Calling-Functions][Calling Functions]] 。

*** 2.3.14 Macro Type
    A Lisp macro is a user-defined construct that extends the Lisp language. It is represented as an object much like a function, but with different argument-passing semantics. A Lisp macro has the form of a list whose first element is the symbol macro and whose cdr is a Lisp function object, including the lambda symbol.

    Lisp 宏是用户定义的结构，它扩展了 Lisp 语言。它表示为一个非常像函数的对象，但具有不同的参数传递语义。Lisp 宏具有列表的形式，其第一个元素是 macro，其 cdr 是 Lisp 函数对象，包括 lambda 符号。

    Lisp macro objects are usually defined with the built-in defmacro macro, but any list that begins with macro is a macro as far as Emacs is concerned. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Macros.html#Macros][Macros]] , for an explanation of how to write a macro.

    Lisp 宏对象通常使用内置的 defmacro 宏定义，但就 Emacs 而言，任何以 macro 开头的列表都是宏。有关如何编写宏的说明，请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Macros.html#Macros][Macros]] 。

    Warning: Lisp macros and keyboard macros (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Keyboard-Macros.html#Keyboard-Macros][Keyboard Macros]] ) are entirely different things. When we use the word “macro” without qualification, we mean a Lisp macro, not a keyboard macro.

    警告：Lisp 宏和键盘宏（参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Keyboard-Macros.html#Keyboard-Macros][Keyboard Macros]] ）完全不同。 当我们没有限定地使用 “macro” 这个词时，我们指的是 Lisp 宏，而不是键盘宏。

*** 2.3.15 Primitive Function Type
    A primitive function is a function callable from Lisp but written in the C programming language. Primitive functions are also called subrs or built-in functions. (The word “subr” is derived from “subroutine”.) Most primitive functions evaluate all their arguments when they are called. A primitive function that does not evaluate all its arguments is called a special form (see Special Forms).

    It does not matter to the caller of a function whether the function is primitive. However, this does matter if you try to redefine a primitive with a function written in Lisp. The reason is that the primitive function may be called directly from C code. Calls to the redefined function from Lisp will use the new definition, but calls from C code may still use the built-in definition. Therefore, we discourage redefinition of primitive functions.

    The term function refers to all Emacs functions, whether written in Lisp or C. See Function Type, for information about the functions written in Lisp.

    Primitive functions have no read syntax and print in hash notation with the name of the subroutine.

    #+BEGIN_EXAMPLE
     (symbol-function 'car)          ; Access the function cell
                                     ;   of the symbol.
          ⇒ #<subr car>
     (subrp (symbol-function 'car))  ; Is this a primitive function?
          ⇒ t                       ; Yes.
    #+END_EXAMPLE

*** 2.3.16 Byte-Code Function Type
    Byte-code function objects are produced by byte-compiling Lisp code (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Byte-Compilation.html#Byte-Compilation][Byte Compilation]] ). Internally, a byte-code function object is much like a vector; however, the evaluator handles this data type specially when it appears in a function call. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Byte_002dCode-Objects.html#Byte_002dCode-Objects][Byte-Code Objects]] .

    字节码函数对象由字节编译 Lisp 代码生成（参见[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Byte-Compilation.html#Byte-Compilation][Byte Compilation]] ）。在内部，字节码函数对象很像 vector;  但是，在函数调用中时此数据类型的求值处理比较特殊。请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Byte_002dCode-Objects.html#Byte_002dCode-Objects][Byte-Code Objects]] 。

    The printed representation and read syntax for a byte-code function object is like that for a vector, with an additional ‘#’ before the opening ‘[’.

    字节码函数对象的打印表示和读取语法类似于 vector，在开头'['之前还有一个'#'。

*** 2.3.17 Record Type
    A record is much like a vector. However, the first element is used to hold its type as returned by type-of. The purpose of records is to allow programmers to create objects with new types that are not built into Emacs.

    record 很像 vector。但是，第一个元素用于保存 type-of 返回的类型。record 的目的是允许程序员使用未构建到 Emacs 中的新类型创建对象。

    See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Records.html#Records][Records]] , for functions that work with records.

    有关使用记录的函数，请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Records.html#Records][Records]] 。

*** 2.3.18 Type Descriptors
    A type descriptor is a record which holds information about a type. Slot 1 in the record must be a symbol naming the type, and type-of relies on this to return the type of record objects. No other type descriptor slot is used by Emacs; they are free for use by Lisp extensions.

    类型描述符是保存有关类型的信息的记录。记录中的 slot 1 必须是命名类型的符号，而 type-of 依赖于此返回记录对象的类型。Emacs 没有使用其他类型描述符 slot; Lisp 扩展可以自由使用它们。

    An example of a type descriptor is any instance of cl-structure-class.

    类型描述符的示例是 cl-structure-class 的任何实例。

*** 2.3.19 Autoload Type
    An autoload object is a list whose first element is the symbol autoload. It is stored as the function definition of a symbol, where it serves as a placeholder for the real definition. The autoload object says that the real definition is found in a file of Lisp code that should be loaded when necessary. It contains the name of the file, plus some other information about the real definition.

    自动加载对象是一个列表，其第一个元素是符号 autoload。它存储为符号的函数定义，用作实际定义的占位符。 自动加载对象表示真正的定义是在 Lisp 代码文件中找到的，应该在必要时加载。 它包含文件的名称，以及有关实际定义的一些其他信息。

    After the file has been loaded, the symbol should have a new function definition that is not an autoload object. The new definition is then called as if it had been there to begin with. From the user's point of view, the function call works as expected, using the function definition in the loaded file.

    加载文件后，符号应具有新函数定义，而不是自动加载对象。调用新定义时好像它一开始就在直在那里。 从用户的角度来看，函数调用使用加载文件中的函数定义按预期工作。

    An autoload object is usually created with the function autoload, which stores the object in the function cell of a symbol. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Autoload.html#Autoload][Autoload]] , for more details.

    自动加载对象通常使用 autoload 函数创建，该功能将对象存储在符号的函数单元中。详见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Autoload.html#Autoload][Autoload]] 。

*** 2.3.20 Finalizer Type
    A finalizer object helps Lisp code clean up after objects that are no longer needed. A finalizer holds a Lisp function object. When a finalizer object becomes unreachable after a garbage collection pass, Emacs calls the finalizer's associated function object. When deciding whether a finalizer is reachable, Emacs does not count references from finalizer objects themselves, allowing you to use finalizers without having to worry about accidentally capturing references to finalized objects themselves.

    当对象不再需要后，finalizer 对象帮助 Lisp 代码进行清理。finalizer 包含一个 Lisp 函数对象。当垃圾收集传递后，finalizer 对象变得无法访问时，Emacs 将调用 finalizer 的关联函数对象。在确定 finalizer 是否可达时，Emacs 不计算 finalizer 对象本身的引用，允许您使用 finalizer 而不必担心意外捕获对已终结对象本身的引用。

    Errors in finalizers are printed to =*Messages*= . Emacs runs a given finalizer object's associated function exactly once, even if that function fails.

    finalizer 中的错误将打印到 =*Messages*= 。即使该函数失败，Emacs 也只运行一次给定的 finalizer 对象的关联函数。

    + Function: make-finalizer function

      Make a finalizer that will run function. function will be called after garbage collection when the returned finalizer object becomes unreachable. If the finalizer object is reachable only through references from finalizer objects, it does not count as reachable for the purpose of deciding whether to run function. function will be run once per finalizer object.

      制作一个将运行功能的 finalizer。当返回的 finalizer 对象变得无法访问时，将在垃圾回收后调用该函数。如果 finalizer 对象只能通过 finalizer 对象的引用来访问，则为了决定是否运行函数，它不计为可达。每个 finalizer 对象将运行一次函数。

** 2.4 Editing Types
   The types in the previous section are used for general programming purposes, and most of them are common to most Lisp dialects. Emacs Lisp provides several additional data types for purposes connected with editing.

   上一节中的类型用于一般编程目的，并且大多数类型对于大多数 Lisp 方言是常见的。Emacs Lisp 提供了几种额外的数据类型用于编辑。

   + Buffer Type: The basic object of editing.

     缓冲区类型：编辑的基本对象。

   + Marker Type: A position in a buffer.

     标记类型：缓冲区中的位置。

   + Window Type: Buffers are displayed in windows.

     窗口类型：缓冲区显示在窗口中。

   + Frame Type: Windows subdivide frames.

     帧类型：Windows 细分出的帧。

   + Terminal Type: A terminal device displays frames.

     终端类型：显示帧的终端设备。

   + Window Configuration Type: Recording the way a frame is subdivided.

     窗口配置类型：记录帧细分的方式。

   + Frame Configuration Type: Recording the status of all frames.

     帧配置类型：记录所有帧的状态。

   + Process Type: A subprocess of Emacs running on the underlying OS.

     进程类型：在底层操作系统上运行的 Emacs 的子进程。

   + Thread Type: A thread of Emacs Lisp execution.

     线程类型：Emacs Lisp 执行的线程。

   + Mutex Type: An exclusive lock for thread synchronization.

     互斥锁类型：线程同步的独占锁。

   + Condition Variable Type: Condition variable for thread synchronization.

     条件变量类型：线程同步的条件变量。

   + Stream Type: Receive or send characters.

     流类型：接收或发送字符。

   + Keymap Type: What function a keystroke invokes.

     键映射类型：键击调用的功能。

   + Overlay Type: How an overlay is represented.

     叠加类型：如何表示叠加层。

   + Font Type: Fonts for displaying text.

     字体类型：用于显示文本的字体。

*** 2.4.1 Buffer Type
    A buffer is an object that holds text that can be edited (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffers.html#Buffers][Buffers]] ). Most buffers hold the contents of a disk file (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Files.html#Files][Files]] ) so they can be edited, but some are used for other purposes. Most buffers are also meant to be seen by the user, and therefore displayed, at some time, in a window (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Windows.html#Windows][Windows]] ). But a buffer need not be displayed in any window. Each buffer has a designated position called point (see  [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Positions.html#Positions][Positions]] ); most editing commands act on the contents of the current buffer in the neighborhood of point. At any time, one buffer is the current buffer.

    缓冲区是一个保存可编辑文本的对象（请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffers.html#Buffers][Buffers]] ）。大多数缓冲区加载磁盘文件的内容（请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Files.html#Files][Files]]  ），以便可以对其进行编辑，但有些缓冲区用于其他目的。大多数缓冲区也可以由用户看到，因此在某个时间显示在窗口中（参见  [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Windows.html#Windows][Windows]] ）。但是不需要在任何窗口中显示缓冲区。每个缓冲区都有一个叫做 point 的指定位置（见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Positions.html#Positions][Positions]] ）; 大多数编辑命令作用于当前缓冲区中点附近的内容。在任何时候，一个缓冲区是当前缓冲区。

    The contents of a buffer are much like a string, but buffers are not used like strings in Emacs Lisp, and the available operations are different. For example, you can insert text efficiently into an existing buffer, altering the buffer's contents, whereas inserting text into a string requires concatenating substrings, and the result is an entirely new string object.

    缓冲区的内容很像字符串，但 Emacs Lisp 中缓冲区不像 字符串那样使用，可用的操作也不同。例如，您可以将文本有效地插入到现有缓冲区中，更改缓冲区的内容，而将文本插入字符串需要连接子字符串，结果是一个全新的字符串对象。

    Many of the standard Emacs functions manipulate or test the characters in the current buffer; a whole chapter in this manual is devoted to describing these functions (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Text.html#Text][Text]] ).

    许多标准 Emacs 函数操作或测试当前缓冲区中的字符; 本手册的整个章节专门用于描述这些功能（参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Text.html#Text][Text]] ）。

    Several other data structures are associated with each buffer:

    其他几个数据结构与每个缓冲区相关联：

    + a local syntax table (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Tables.html#Syntax-Tables][Syntax Tables]]);
      本地语法表（参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Tables.html#Syntax-Tables][Syntax Tables]]）;

    + a local keymap (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Keymaps.html#Keymaps][Keymaps]]); and,

      本地键映射（参见[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Keymaps.html#Keymaps][Keymaps]]）; 和，

    + a list of buffer-local variable bindings (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer_002dLocal-Variables.html#Buffer_002dLocal-Variables][Buffer-Local Variables]]).

      缓冲区局部变量绑定列表（请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer_002dLocal-Variables.html#Buffer_002dLocal-Variables][Buffer-Local Variables]]）。

    + overlays (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Overlays.html#Overlays][Overlays]]).

      叠加（请参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Overlays.html#Overlays][Overlays]]）。

    + text properties for the text in the buffer (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Properties.html#Text-Properties][Text Properties]]).

      缓冲区中文本的文本属性（请参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Properties.html#Text-Properties][Text Properties]]）。

    The local keymap and variable list contain entries that individually override global bindings or values. These are used to customize the behavior of programs in different buffers, without actually changing the programs.

    本地键映射和变量列表包含单独覆盖全局绑定或值的条目。这些用于自定义不同缓冲区中程序的行为，而无需实际更改程序。

    A buffer may be indirect, which means it shares the text of another buffer, but presents it differently. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Indirect-Buffers.html#Indirect-Buffers][Indirect Buffers]].

    缓冲区可以是间接的，这意味着它共享另一个缓冲区的文本，但以不同的方式呈现它。请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Indirect-Buffers.html#Indirect-Buffers][Indirect Buffers]]。

    Buffers have no read syntax. They print in hash notation, showing the buffer name.

    缓冲区没有读取语法。它们以哈希表示法打印，显示缓冲区名称。

    #+BEGIN_EXAMPLE
     (current-buffer)
          ⇒ #<buffer objects.texi>

    #+END_EXAMPLE

*** 2.4.2 Marker Type
    A marker denotes a position in a specific buffer. Markers therefore have two components: one for the buffer, and one for the position. Changes in the buffer's text automatically relocate the position value as necessary to ensure that the marker always points between the same two characters in the buffer.

    标记表示特定缓冲区中的位置。 因此，标记有两个组成部分：缓冲区和位置。 更改缓冲区文本中的会根据需要自动重定位位置值，以确保标记始终指向缓冲区中相同的两个字符。

    Markers have no read syntax. They print in hash notation, giving the current character position and the name of the buffer.

    标记没有读取语法。 它们以散列表示法打印，给出当前字符位置和缓冲区的名称。
    #+BEGIN_EXAMPLE
     (point-marker)
          ⇒ #<marker at 10779 in objects.texi>
    #+END_EXAMPLE

    See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Markers.html#Markers][Markers]] , for information on how to test, create, copy, and move markers.

    有关如何测试，创建，复制和移动标记，请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Markers.html#Markers][Markers]] 。

*** 2.4.3 Window Type
    A window describes the portion of the terminal screen that Emacs uses to display a buffer. Every window has one associated buffer, whose contents appear in the window. By contrast, a given buffer may appear in one window, no window, or several windows.

    窗口描述了 Emacs 用于显示缓冲区的终端屏幕部分。每个窗口都有一个关联的缓冲区，其内容显示在窗口中。相比之下，给定的缓冲区可能出现在一个窗口，没有窗口或几个窗口。

    Though many windows may exist simultaneously, at any time one window is designated the selected window. This is the window where the cursor is (usually) displayed when Emacs is ready for a command. The selected window usually displays the current buffer (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Current-Buffer.html#Current-Buffer][Current Buffer]] ), but this is not necessarily the case.

    尽管可以同时存在许多窗口，但是在任何时候只有一个被指定为所选择的窗口。它是当 Emacs 准备好命令时（通常）显示光标的窗口。所选窗口通常显示当前缓冲区（请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Current-Buffer.html#Current-Buffer][Current Buffer]] ），但不一定是这种情况。

    Windows are grouped on the screen into frames; each window belongs to one and only one frame. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Type.html#Frame-Type][Frame Type]].

    Windows 在屏幕上分组为 frames; 每个窗口属于一个且只有一个帧。请参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Type.html#Frame-Type][Frame Type]]。

    Windows have no read syntax. They print in hash notation, giving the window number and the name of the buffer being displayed. The window numbers exist to identify windows uniquely, since the buffer displayed in any given window can change frequently.

    Windows 没有读取语法。它们以散列表示法打印，给出窗口号和正在显示的缓冲区的名称。存在窗口编号以唯一地标识窗口，因为在任何给定窗口中显示的缓冲区可以频繁地改变。

    #+BEGIN_EXAMPLE
     (selected-window)
          ⇒ #<window 1 on objects.texi>
    #+END_EXAMPLE

    See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Windows.html#Windows][Windows]] , for a description of the functions that work on windows.

    有关在 Windows 上运行的功能的说明，请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Windows.html#Windows][Windows]] 。

*** 2.4.4 Frame Type
    A frame is a screen area that contains one or more Emacs windows; we also use the term “frame” to refer to the Lisp object that Emacs uses to refer to the screen area.

    frame 是包含一个或多个 Emacs window 的屏幕区域; 我们还使用术语 “frame” 来指代 Emacs 用来引用屏幕区域的 Lisp 对象。

    Frames have no read syntax. They print in hash notation, giving the frame's title, plus its address in core (useful to identify the frame uniquely).

    frame 没有读取语法。 它们以散列表示法打印，给出 frame 的标题，以及核心地址（用于唯一标识 frame）。

    #+BEGIN_EXAMPLE
     (selected-frame)
          ⇒ #<frame emacs@psilocin.gnu.org 0xdac80>
    #+END_EXAMPLE

    See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Frames.html#Frames][Frames]] , for a description of the functions that work on frames.

    有关对框架起作用的函数的说明，请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Frames.html#Frames][Frames]] 。

*** 2.4.5 Terminal Type
    A terminal is a device capable of displaying one or more Emacs frames (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Type.html#Frame-Type][Frame Type]]).

    终端是能够显示一个或多个 Emacs frame 的设备（参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Type.html#Frame-Type][Frame Type]]）。

    Terminals have no read syntax. They print in hash notation giving the terminal's ordinal number and its TTY device file name.

    终端没有读取语法。 它们以散列表示法打印，给出终端的序号和 TTY 设备文件名。

    #+BEGIN_EXAMPLE
     (get-device-terminal nil)
          ⇒ #<terminal 1 on /dev/tty>
    #+END_EXAMPLE

*** 2.4.6 Window Configuration Type
    A window configuration stores information about the positions, sizes, and contents of the windows in a frame, so you can recreate the same arrangement of windows later.

    窗口配置存储有关 frame 中窗口的位置，大小和内容的信息，因此可以稍后重新创建相同的窗口排列。

    Window configurations do not have a read syntax; their print syntax looks like ‘#<window-configuration>’. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Window-Configurations.html#Window-Configurations][Window Configurations]], for a description of several functions related to window configurations.

    窗口配置没有读取语法;  它们的打印语法类似于 “＃<window-configuration>”。 有关窗口配置的若干功能的说明，请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Window-Configurations.html#Window-Configurations][Window Configurations]]。

*** 2.4.7 Frame Configuration Type
    A frame configuration stores information about the positions, sizes, and contents of the windows in all frames. It is not a primitive type—it is actually a list whose car is frame-configuration and whose cdr is an alist. Each alist element describes one frame, which appears as the car of that element.

    帧配置存储关于所有帧中的窗口的位置，大小和内容的信息。 它不是原始类型 - 它实际上是一个列表，其 car 是 frame-configuration， 其 cdr 是 alist。每个 alist 元素描述一个 frame，frame 作为该元素的 car。

    See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Configurations.html#Frame-Configurations][Frame Configurations]], for a description of several functions related to frame configurations.
    有关帧配置的若干功能的说明，请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Configurations.html#Frame-Configurations][Frame Configurations]]。

*** 2.4.8 Process Type
    The word process usually means a running program. Emacs itself runs in a process of this sort. However, in Emacs Lisp, a process is a Lisp object that designates a subprocess created by the Emacs process. Programs such as shells, GDB, ftp, and compilers, running in subprocesses of Emacs, extend the capabilities of Emacs. An Emacs subprocess takes textual input from Emacs and returns textual output to Emacs for further manipulation. Emacs can also send signals to the subprocess.

    进程通常意味着正在运行的程序。Emacs 本身就是在这种进程中运行的。但是，在 Emacs Lisp 中，进程是一个 Lisp 对象，它指定由 Emacs 进程创建的子进程。在 Emacs 的子进程中运行的诸如 shell，GDB，ftp 和编译器之类的程序扩展了 Emacs 的功能。Emacs 子进程从 Emacs 获取文本输入，并将文本输出返回给 Emacs 以进行进一步操作。Emacs 还可以向子进程发送信号。

    Process objects have no read syntax. They print in hash notation, giving the name of the process:

    进程对象没有读取语法。它们以哈希表示法打印，给出进程的名称：

    #+BEGIN_EXAMPLE
     (process-list)
          ⇒ (#<process shell>)
    #+END_EXAMPLE

    See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Processes.html#Processes][Processes]] , for information about functions that create, delete, return information about, send input or signals to, and receive output from processes.

    有关进程创建，删除，返回有关，向其发送输入或信号以及从进程接收输出的信息的功能的信息，请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Processes.html#Processes][Processes]] 。

*** 2.4.9 Thread Type
    A thread in Emacs represents a separate thread of Emacs Lisp execution. It runs its own Lisp program, has its own current buffer, and can have subprocesses locked to it, i.e. subprocesses whose output only this thread can accept. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Threads.html#Threads][Threads]].

    Emacs 中的线程表示 Emacs Lisp 单独执行的线程。它运行自己的 Lisp 程序，有自己的当前缓冲区，并且可以锁定子进程，例如，只有这个线程可以接受的输出的子进程。 参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Threads.html#Threads][Threads]] 。

    Thread objects have no read syntax. They print in hash notation, giving the name of the thread (if it has been given a name) or its address in core:

    线程对象没有读取语法。它们以哈希表示法打印，给出线程的名称（如果它已被赋予名称）或其在核心中的地址：

    #+BEGIN_EXAMPLE
     (all-threads)
         ⇒ (#<thread 0176fc40>)
    #+END_EXAMPLE

*** 2.4.10 Mutex Type
    A mutex is an exclusive lock that threads can own and disown, in order to synchronize between them. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Mutexes.html#Mutexes][Mutexes]].

    互斥锁是线程可以拥有和释放的独占锁，以便在它们之间进行同步。请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Mutexes.html#Mutexes][Mutexes]].。

    Mutex objects have no read syntax. They print in hash notation, giving the name of the mutex (if it has been given a name) or its address in core:

    互斥对象没有读取语法。 它们以哈希表示法打印，给出互斥锁的名称（如果它已被赋予名称）或其核心地址：

    #+BEGIN_EXAMPLE
     (make-mutex "my-mutex")
         ⇒ #<mutex my-mutex>
     (make-mutex)
         ⇒ #<mutex 01c7e4e0>
    #+END_EXAMPLE

*** 2.4.11 Condition Variable Type
    A condition variable is a device for a more complex thread synchronization than the one supported by a mutex. A thread can wait on a condition variable, to be woken up when some other thread notifies the condition.

    条件变量是比互斥锁更复杂的线程同步的设备。线程可以等待一个条件变量，当一些其他线程通知该条件时被唤醒。

    Condition variable objects have no read syntax. They print in hash notation, giving the name of the condition variable (if it has been given a name) or its address in core:

    条件变量对象没有读取语法。 它们以哈希表示法打印，给出条件变量的名称（如果它已被赋予名称）或其在核心中的地址：

    #+BEGIN_EXAMPLE
     (make-condition-variable (make-mutex))
         ⇒ #<condvar 01c45ae8>
    #+END_EXAMPLE

*** 2.4.12 Stream Type
    A stream is an object that can be used as a source or sink for characters—either to supply characters for input or to accept them as output. Many different types can be used this way: markers, buffers, strings, and functions. Most often, input streams (character sources) obtain characters from the keyboard, a buffer, or a file, and output streams (character sinks) send characters to a buffer, such as a =*Help*= buffer, or to the echo area.

    流是一个对象，可以用作字符的源或接收器 - 为输入提供字符或接受它们作为输出。 许多不同类型可以这样使用：标记，缓冲区，字符串和函数。 大多数情况下，输入流（字符源）从键盘，缓冲区或文件中获取字符，输出流（字符接收器）将字符发送到缓冲区（如 =*Help*= 缓冲区）或回显区域。

    The object nil, in addition to its other meanings, may be used as a stream. It stands for the value of the variable standard-input or standard-output. Also, the object t as a stream specifies input using the minibuffer (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Minibuffers.html#Minibuffers][Minibuffers]] ) or output in the echo area (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/The-Echo-Area.html#The-Echo-Area][The Echo Area]] ).

    对象 nil 除了其他含义之外，也可以用作流。它代表可变标准输入或标准输出的值。此外，作为流的对象 t 使用 mini buffer 作为特殊输入（请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Minibuffers.html#Minibuffers][Minibuffers]] ）或回显区作为输出（请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/The-Echo-Area.html#The-Echo-Area][The Echo Area]] ）。

    Streams have no special printed representation or read syntax, and print as whatever primitive type they are.

    流没有特殊的打印表示或读取语法，打印输出它们的原始类型。

    See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Read-and-Print.html#Read-and-Print][Read and Print]] , for a description of functions related to streams, including parsing and printing functions.

    请参阅  [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Read-and-Print.html#Read-and-Print][Read and Print]] 了解与流相关的功能的说明，包括解析和打印功能。

*** 2.4.13 Keymap Type
    A keymap maps keys typed by the user to commands. This mapping controls how the user's command input is executed. A keymap is actually a list whose car is the symbol keymap.

    键映射将用户键入的键映射到命令。此映射控制用户命令输入的执行方式。键映射实际上是一个列表，其 car 是 符号 keymap。

    See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Keymaps.html#Keymaps][Keymaps]], for information about creating keymaps, handling prefix keys, local as well as global keymaps, and changing key bindings.

    有关创建键映射，处理前缀键，本地键和全局键映射以及更改键绑定的信息，请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Keymaps.html#Keymaps][Keymaps]]。

*** 2.4.14 Overlay Type
    An overlay specifies properties that apply to a part of a buffer. Each overlay applies to a specified range of the buffer, and contains a property list (a list whose elements are alternating property names and values). Overlay properties are used to present parts of the buffer temporarily in a different display style. Overlays have no read syntax, and print in hash notation, giving the buffer name and range of positions.

    overlay 指定适用于缓冲区中一部分的属性。 每个 overlay 都应用于缓冲区的指定范围，并包含属性列表（其元素为交替属性名称和值的列表）。overlay 属性用于以不同的显示样式临时呈现缓冲区的一部分。overlay 没有读取语法，并以散列表示法打印，给出缓冲区名称和位置范围。

    See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Overlays.html#Overlays][Overlays]], for information on how you can create and use overlays.
    有关如何创建和使用 overlay 的信息，请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Overlays.html#Overlays][Overlays]] 。

*** 2.4.15 Font Type
    A font specifies how to display text on a graphical terminal. There are actually three separate font types—font objects, font specs, and font entities—each of which has slightly different properties. None of them have a read syntax; their print syntax looks like ‘#<font-object>’, ‘#<font-spec>’, and ‘#<font-entity>’ respectively. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Low_002dLevel-Font.html#Low_002dLevel-Font][Low-Level Font]], for a description of these Lisp objects.

    字体指定如何在图形终端上显示文本。实际上有三种不同的字体类型-字体对象，字体规格和字体实体 - 它们具有略微不同的属性。它们都没有读取语法;  它们的打印语法分别类似于 “＃<font-object>”，“＃font-spec>” 和 “＃<font-entity>”。 有关这些 Lisp 对象的说明，请参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Low_002dLevel-Font.html#Low_002dLevel-Font][Low-Level Font]]。


** 2.5 Read Syntax for Circular Objects

   To represent shared or circular structures within a complex of Lisp objects, you can use the reader constructs ‘#n=’ and ‘#n#’.
   要在 Lisp 对象的复合体中表示共享或循环结构，可以使用 reader 构造'#n ='和'#n＃'。

   Use #n= before an object to label it for later reference; subsequently, you can use #n# to refer the same object in another place. Here, n is some integer. For example, here is how to make a list in which the first element recurs as the third element:

   在对象之前使用 #n= 标记它以供以后参考; 随后，您可以使用 #n＃在另一个地方引用同一个对象。这里，n 是一些整数。例如，以下是如何创建第一个元素作为第三个元素重复出现的列表：

   #+BEGIN_SRC elisp
     (#1=(a) b #1#)
   #+END_SRC

   This differs from ordinary syntax such as this

   这与诸如此类的普通语法不同：

   #+BEGIN_SRC elisp
     ((a) b (a))
   #+END_SRC

   which would result in a list whose first and third elements look alike but are not the same Lisp object. This shows the difference:

   这将产生一个列表，其第一个和第三个元素看起来相似，但不是相同的 Lisp 对象。这显示了不同之处：

   #+BEGIN_EXAMPLE
     (prog1 nil
       (setq x '(#1=(a) b #1#)))
     (eq (nth 0 x) (nth 2 x))
          ⇒ t
     (setq x '((a) b (a)))
     (eq (nth 0 x) (nth 2 x))
          ⇒ nil
   #+END_EXAMPLE

   You can also use the same syntax to make a circular structure, which appears as an element within itself. Here is an example:

   还可以使用相同的语法来创建循环结构，该结构在其自身中显示为元素。这是一个例子：

   #+BEGIN_SRC elisp
     #1=(a #1#)
   #+END_SRC

   This makes a list whose second element is the list itself. Here's how you can see that it really works:

   这使得列表的第二个元素是列表本身。以下是您可以看到它确实有效的方法：
   #+BEGIN_EXAMPLE
     (prog1 nil
       (setq x '#1=(a #1#)))
     (eq x (cadr x))
          ⇒ t
   #+END_EXAMPLE
   The Lisp printer can produce this syntax to record circular and shared structure in a Lisp object, if you bind the variable print-circle to a non-nil value. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Output-Variables.html#Output-Variables][Output Variables]].

   如果将变量 print-circle 绑定到非零值，Lisp printer 可以生成此语法以记录在 Lisp 对象中 的循环和共享结构。请参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Output-Variables.html#Output-Variables][Output Variables]]。

** 2.6 Type Predicates
   The Emacs Lisp interpreter itself does not perform type checking on the actual arguments passed to functions when they are called. It could not do so, since function arguments in Lisp do not have declared data types, as they do in other programming languages. It is therefore up to the individual function to test whether each actual argument belongs to a type that the function can use.

   当调用函数时，Emacs Lisp 解释器本身不会对传递的实际参数执行类型检查。它不能这样做，因为 Lisp 中的函数参数没有声明数据类型，就像在其他编程语言中一样。因此，由单个函数来测试每个实际参数是否属于函数可以使用的类型。

   All built-in functions do check the types of their actual arguments when appropriate, and signal a wrong-type-argument error if an argument is of the wrong type. For example, here is what happens if you pass an argument to + that it cannot handle:

   所有内置函数都会在适当时检查其实际参数的类型，如果参数类型错误，则发出 wrong-type-argument 错误。例如，如果将无法处理的参数传递给+ ，会发生以下情况：

   #+BEGIN_EXAMPLE
     (+ 2 'a)
          error--> Wrong type argument: number-or-marker-p, a
   #+END_EXAMPLE

   If you want your program to handle different types differently, you must do explicit type checking. The most common way to check the type of an object is to call a type predicate function. Emacs has a type predicate for each type, as well as some predicates for combinations of types.

   如果希望程序以不同方式处理不同类型，则必须进行显式类型检查。检查对象类型的最常用方法是调用类型谓词函数。每种类型 Emacs 都有一个类型谓词，以及一些类型组合的谓词。

   A type predicate function takes one argument; it returns t if the argument belongs to the appropriate type, and nil otherwise. Following a general Lisp convention for predicate functions, most type predicates' names end with ‘p’.

   类型谓词函数接受一个参数; 如果参数属于适当的类型，则返回 t，否则返回 nil。遵循谓词函数的一般 Lisp 约定，大多数类型谓词的名称以'p'结尾。

   Here is an example which uses the predicates listp to check for a list and symbolp to check for a symbol.

   下面是一个使用谓词 listp 检查列表和 symbolp 来检查符号的示例。

   #+BEGIN_SRC elisp
     (defun add-on (x)
       (cond ((symbolp x)
              ;; If X is a symbol, put it on LIST.
              (setq list (cons x list)))
             ((listp x)
              ;; If X is a list, add its elements to LIST.
              (setq list (append x list)))
             (t
              ;; We handle only symbols and lists.
              (error "Invalid argument %s in add-on" x))))
   #+END_SRC

   Here is a table of predefined type predicates, in alphabetical order, with references to further information.

   下面是按字母顺序排列的预定义类型谓词表，其中包含对更多信息的引用。
   (译者注：省略，参见[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Type-Predicates.html#Type-Predicates][原文]])

   The most general way to check the type of an object is to call the function type-of. Recall that each object belongs to one and only one primitive type; type-of tells you which one (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Lisp-Data-Types.html#Lisp-Data-Types][Lisp Data Types]]). But type-of knows nothing about non-primitive types. In most cases, it is more convenient to use type predicates than type-of.

   检查对象类型的最常用方法是调用函数 type-of。回想一下，每个对象属于一种且只有一种基本类型; type-of 告诉你哪一个（参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Lisp-Data-Types.html#Lisp-Data-Types][Lisp Data Types]]）。 但是 type-of 对非原始类型一无所知。 在大多数情况下，使用类型谓词比使用 type-of 更方便。

   + Function: type-of object

     This function returns a symbol naming the primitive type of object. The value is one of the symbols bool-vector, buffer, char-table, compiled-function, condition-variable, cons, finalizer, float, font-entity, font-object, font-spec, frame, hash-table, integer, marker, mutex, overlay, process, string, subr, symbol, thread, vector, window, or window-configuration. However, if object is a record, the type specified by its first slot is returned; Records.

     此函数返回指定对象的基本类型的符号。 该值是下列符号之一：bool-vector, buffer, char-table, compiled-function, condition-variable, cons, finalizer, float, font-entity, font-object, font-spec, frame, hash-table, integer, marker, mutex, overlay, process, string, subr, symbol, thread, vector, window, or window-configuration 但是，如果 object 是 record，则返回其第一个 slot 指定的类型；

     #+BEGIN_EXAMPLE
          (type-of 1)
               ⇒ integer
          (type-of 'nil)
               ⇒ symbol
          (type-of '())    ; () is nil.
               ⇒ symbol
          (type-of '(x))
               ⇒ cons
          (type-of (record 'foo))
               ⇒ foo

     #+END_EXAMPLE

** 2.7 Equality Predicates

   Here we describe functions that test for equality between two objects. Other functions test equality of contents between objects of specific types, e.g., strings. For these predicates, see the appropriate chapter describing the data type.

   此处描述测试两个对象之间相等性的函数。其他函数测试特定类型的对象（例如字符串）之间的内容的相等性。 对于这些谓词，请参阅描述数据类型的相应章节。

   + Function: eq object1 object2

     This function returns t if object1 and object2 are the same object, and nil otherwise.

     如果 object1 和 object2 是同一个对象，则此函数返回 t，否则返回 nil。

     If object1 and object2 are integers with the same value, they are considered to be the same object (i.e., eq returns t). If object1 and object2 are symbols with the same name, they are normally the same object—but see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Symbols.html#Creating-Symbols][Creating Symbols]] for exceptions. For other types (e.g., lists, vectors, strings), two arguments with the same contents or elements are not necessarily eq to each other: they are eq only if they are the same object, meaning that a change in the contents of one will be reflected by the same change in the contents of the other.

     如果 object1 和 object2 是具有相同值的整数，则它们被认为是同一个对象（即，eq 返回 t）。 如果 object1 和 object2 是具有相同名称的符号，则它们通常是相同的对象 - 但请参阅 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Symbols.html#Creating-Symbols][Creating Symbols]] 了解异常。 对于其他类型（例如，列表，向量，字符串），具有相同内容或元素的两个参数不一定彼此相等：只有当它们是同一个对象时它们才是 eq，这意味着更改一个的内容，对方内容的相同出现相同的变化。

     #+BEGIN_EXAMPLE
          (eq 'foo 'foo)
               ⇒ t

          (eq 456 456)
               ⇒ t

          (eq "asdf" "asdf")
               ⇒ nil

          (eq "" "")
               ⇒ t
          ;; This exception occurs because Emacs Lisp
          ;; makes just one multibyte empty string, to save space.

          (eq '(1 (2 (3))) '(1 (2 (3))))
               ⇒ nil

          (setq foo '(1 (2 (3))))
               ⇒ (1 (2 (3)))
          (eq foo foo)
               ⇒ t
          (eq foo '(1 (2 (3))))
               ⇒ nil

          (eq [(1 2) 3] [(1 2) 3])
               ⇒ nil

          (eq (point-marker) (point-marker))
               ⇒ nil
     #+END_EXAMPLE

     The make-symbol function returns an uninterned symbol, distinct from the symbol that is used if you write the name in a Lisp expression. Distinct symbols with the same name are not eq. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Symbols.html#Creating-Symbols][Creating Symbols]].

     make-symbol 函数返回一个未处理的符号，与在 Lisp 表达式中写入名称时使用的符号不同。 具有相同名称的不同符号不是 eq。请参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Symbols.html#Creating-Symbols][Creating Symbols]]。

     #+BEGIN_EXAMPLE
          (eq (make-symbol "foo") 'foo)
               ⇒ nil
     #+END_EXAMPLE

   + Function: equal object1 object2

     This function returns t if object1 and object2 have equal components, and nil otherwise. Whereas eq tests if its arguments are the same object, equal looks inside nonidentical arguments to see if their elements or contents are the same. So, if two objects are eq, they are equal, but the converse is not always true.

     如果 object1 和 object2 具有相等的组件，则此函数返回 t，否则返回 nil。 虽然 eq 测试它的参数是否是同一个对象，但是 equal 在不同的参数内部查看它们的元素或内容是否相同。 因此，如果两个对象是 eq，它们是相等的，但反过来并不总是正确的。

     #+BEGIN_EXAMPLE
          (equal 'foo 'foo)
               ⇒ t

          (equal 456 456)
               ⇒ t

          (equal "asdf" "asdf")
               ⇒ t
          (eq "asdf" "asdf")
               ⇒ nil

          (equal '(1 (2 (3))) '(1 (2 (3))))
               ⇒ t
          (eq '(1 (2 (3))) '(1 (2 (3))))
               ⇒ nil

          (equal [(1 2) 3] [(1 2) 3])
               ⇒ t
          (eq [(1 2) 3] [(1 2) 3])
               ⇒ nil

          (equal (point-marker) (point-marker))
               ⇒ t

          (eq (point-marker) (point-marker))
               ⇒ nil
     #+END_EXAMPLE

     Comparison of strings is case-sensitive, but does not take account of text properties—it compares only the characters in the strings. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Properties.html#Text-Properties][Text Properties]]. Use equal-including-properties to also compare text properties. For technical reasons, a unibyte string and a multibyte string are equal if and only if they contain the same sequence of character codes and all these codes are in the range 0 through 127 (ASCII).

     字符串的比较区分大小写，但不考虑文本属性 - 它只比较字符串中的字符。请参见 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Properties.html#Text-Properties][Text Properties]]。使用 equal-including-properties 也可以比较文本属性。由于技术原因，unibyte 字符串和多字节字符串是相等的，当且仅当它们包含相同的字符代码序列且所有这些代码都在 0 到 127（ASCII）范围内时。

     #+BEGIN_EXAMPLE
          (equal "asdf" "ASDF")
               ⇒ nil
     #+END_EXAMPLE

     However, two distinct buffers are never considered equal, even if their textual contents are the same.

     但是，即使两个不同的缓冲区的文本内容相同，也不会认为它们是相等的。

     The test for equality is implemented recursively; for example, given two cons cells x and y, (equal x y) returns t if and only if both the expressions below return t:

     对等式的测试是递归实现的; 例如，给定两个 cons cell x 和 y，（equal x y）返回 t 当且仅当下面的两个表达式返回 t 时：

     #+BEGIN_SRC elisp
     (equal (car x) (car y))
     (equal (cdr x) (cdr y))
     #+END_SRC

     Because of this recursive method, circular lists may therefore cause infinite recursion (leading to an error).

     由于这种递归方法，循环列表因此可能导致无限递归（导致错误）。


   + Function: equal-including-properties object1 object2

     This function behaves like equal in all cases but also requires that for two strings to be equal, they have the same text properties.

     此函数在所有情况下的行为都相同，但也要求两个字符串相等，它们具有相同的文本属性。

     #+BEGIN_EXAMPLE
          (equal "asdf" (propertize "asdf" 'asdf t))
               ⇒ t
          (equal-including-properties "asdf"
                                      (propertize "asdf" 'asdf t))
               ⇒ nil
     #+END_EXAMPLE




* Footnotes

[fn:1] You may also encounter ‘#^^’, used for sub-char-tables.
